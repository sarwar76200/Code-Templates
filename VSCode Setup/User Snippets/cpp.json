{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Print to console": {
		"prefix": "ok${1:item}",
		"body": [
			"console.log('$1');",
			"$2"
		],
		"description": "Log output to console"
	},
	"Sieve of Atkin": {
		"prefix": "atkin",
		"body": [
			"const int MXX = 1e7;",
			"bitset<MXX + 1> isPrime;",
			"",
			"void sieve_a() {",
			"    int sqMX = (int) sqrt(MXX) + 1;",
			"    for (int i = 1; i <= sqMX; ++i) {",
			"        for (int j = 1; j <= sqMX; ++j) {",
			"            int k = 4 * i * i + j * j;",
			"            if (k <= MXX && (k % 12 == 1 || k % 12 == 5)) isPrime.flip(k);",
			"",
			"            k = 3 * i * i + j * j;",
			"            if (k <= MXX && k % 12 == 7) isPrime.flip(k);",
			"            if (i > j) {",
			"                k = 3 * i * i - j * j;",
			"                if (k <= MXX && k % 12 == 11) isPrime.flip(k);",
			"            }",
			"        }",
			"    }",
			"    isPrime[2] = isPrime[3] = true;",
			"    for (int i = 5; i <= sqMX; ++i) {",
			"        if (isPrime[i]) {",
			"            for (int j = i * i; j <= MXX; j += i * i) {",
			"                isPrime[j] = false;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": ""
	},
	"Unix timestamp of a given date": {
		"prefix": "timestamp",
		"body": [
			"uint32_t get_timestamp(int year, int mon, int day, int hr, int min, int sec = 0) {",
			"  tm time{sec, min, hr, day, mon, year - 1900};",
			"  return mktime(&time);",
			"}",
		],
		"description": "Unix timestamp of a given date"
	},
	"Kosaraju's Algorithm for Strongly Connected Components": {
		"prefix": "kosaraju",
		"body": [
			"const int N = 10001;",
			"bool visited[N];",
			"vector<int> seq, comps;",
			"",
			"void dfs(vector<vector<int>>& adj, int u, bool ts = false) {",
			"    visited[u] = true;",
			"    if (!ts) comps.push_back(u);",
			"    for (auto v : adj[u]) {",
			"        if (!visited[v]) {",
			"            dfs(adj, v, ts);",
			"        }",
			"    }",
			"    if (ts) seq.push_back(u);",
			"}",
			"",
			"",
			"void print() {",
			"    for (auto i : comps) cout << i << \" \";",
			"    cout << '\\n';",
			"    comps.clear();",
			"}",
			"",
			"void kosaraju_scc(vector<vector<int>>& adj, vector<vector<int>>& adj_t, int n) {",
			"    for (int i = 1; i <= n; ++i) {",
			"        if (!visited[i]) dfs(adj, i, true);",
			"    }",
			"    reverse(seq.begin(), seq.end());",
			"    memset(visited, false, sizeof visited);",
			"",
			"    for (auto i : seq) {",
			"        if (!visited[i]) {",
			"            dfs(adj_t, i);",
			"            print();",
			"        }",
			"    }",
			"}",
		],
		"description": ""
	},
	"Tokenize a string": {
		"prefix": "tokenize",
		"body": [
			"vector<string> tokenize(string s, char delimiter = ' ') {",
			"    vector<string> tokens;",
			"    stringstream ss(s);",
			"    string t;",
			"    while (getline(ss, t, delimiter)) {",
			"        tokens.push_back(t);",
			"    }",
			"    return tokens;",
			"}",
		],
		"description": ""
	},
	"Breadth First Search": {
		"prefix": "bfs",
		"body": [
			"const int MXX = 5 + 1e5;",
			"",
			"bool vis[MXX];",
			"vector<int> G[MXX];",
			"",
			"void bfs(int s) {",
			"    queue<int> Q;",
			"    Q.push(s);",
			"    while (!Q.empty()) {",
			"        vis[s] = true;",
			"        int curr = Q.front();",
			"        Q.pop();",
			"        for (int next : G[curr]) {",
			"            if (!vis[next]) {",
			"                vis[next] = true;",
			"                Q.push(next);",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": ""
	},
	"Breadth First Search in a 2D grid": {
		"prefix": "bfs2d",
		"body": [
			"const int MXX = 5 + 2e3;",
			"bool vis[MXX][MXX];",
			"int dist[MXX][MXX];",
			"char grid[MXX][MXX];",
			"",
			"void init() {",
			"    for (int i = 0; i < MXX; ++i) {",
			"        for (int j = 0; j < MXX; ++j) {",
			"            vis[i][j] = false, dist[i][j] = INT_MAX;",
			"        }",
			"    }",
			"}",
			"",
			"void reset() {",
			"    init();",
			"    for (auto &i : grid) {",
			"        memset(i, 0, sizeof i);",
			"    }",
			"}",
			"",
			"bool valid(int x, int y) {",
			"    return x >= 0 && x < R && y >= 0 && y < C && !vis[x][y];",
			"}",
			"",
			"void bfs(int sx, int sy) {",
			"    queue<pair<int, int>> Q;",
			"    Q.push({sx, sy});",
			"    vis[sx][sy] = true;",
			"    dist[sx][sy] = 0;",
			"    while (!Q.empty()) {",
			"        int x = Q.front().first, y = Q.front().second;",
			"        Q.pop();",
			"        for (int i = 0; i < 8; ++i) {",
			"            int nx = x + dx[i], ny = y + dy[i];",
			"            if (valid(nx, ny)) {",
			"                vis[nx][ny] = true;",
			"                dist[nx][ny] = dist[x][y] + 1;",
			"                Q.push({nx, ny});",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": ""
	},
	"Breadth First Search : Full Version": {
		"prefix": "bfsFull",
		"body": [
			"const int MXX = 5 + 1e5;",
			"bool vis[MXX];",
			"int dist[MXX], parent[MXX];",
			"vector<int> G[MXX];",
			"",
			"void init() {",
			"    for (int i = 0; i < MXX; ++i) {",
			"        vis[i] = false, dist[i] = INT_MAX, parent[i] = -1;",
			"    }",
			"}",
			"",
			"void reset() {",
			"    init();",
			"    for (auto &i : G) i.clear();",
			"}",
			"",
			"void bfs(int s) {",
			"    dist[s] = 0;",
			"    parent[s] = -1;",
			"    queue<int> Q;",
			"    Q.push(s);",
			"    while (!Q.empty()) {",
			"        vis[s] = true; //disable this in directed graphs",
			"        int curr = Q.front();",
			"        Q.pop();",
			"        for (int next : G[curr]) {",
			"            if (!vis[next]) {",
			"                vis[next] = true;",
			"                dist[next] = dist[curr] + 1;",
			"                parent[next] = curr;",
			"                Q.push(next);",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": ""
	},
	"Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
			"template<typename T = int64_t>",
			"T bin_expo(T b, T e, T m) {",
			"    b %= m;",
			"    T res = 1;",
			"    while (e > 0) {",
			"        if (e & 1) res = b * res % m;",
			"        b = b * b % m;",
			"        e >>= 1;",
			"    }",
			"    return res;",
			"}",
		],
		"description": ""
	},
	"Check if agraph is bipartite or not": {
		"prefix": "bipartite",
		"body": [
			"bool bfs(vector<int> *G, int src, int nodes) {",
			"    int color[nodes + 5];",
			"    for (int &i : color) i = -1;",
			"    color[src] = 1;",
			"    queue<int> Q;",
			"    Q.push(src);",
			"    while (!Q.empty()) {",
			"        int curr = Q.front();",
			"        Q.pop();",
			"        //if (self_loop) return false;",
			"        for (int nxt : G[curr]) {",
			"            if (color[nxt] == -1) {",
			"                color[nxt] = 1 - color[curr];",
			"                Q.push(nxt);",
			"            } else if (color[curr] == color[nxt]) return false;",
			"        }",
			"    }",
			"    return true;",
			"}"
		],
		"description": ""
	},
	"2D Prefix sum": {
		"prefix": "pref2d",
		"body": [
			"const int N = 1000, M = 500;",
			"int a[N + 1][M + 1], pref[N + 1][M + 1];",
			"",
			"// 1-based",
			"void build() {",
			"    for (int i = 1; i <= N; ++i) {",
			"        for (int j = 1; j <= M; ++j) {",
			"            pref[i][j] = pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1] + a[i][j];",
			"        }",
			"    }",
			"}",
			"// top_left(i, j), right_bottom(k, l)",
			"auto query(int i, int j, int k, int l) {",
			"    return pref[k][l] - pref[i - 1][l] - pref[k][j - 1] + pref[i - 1][j - 1];",
			"}"
		],
		"description": ""
	},
	"Macros for Bitwise Operations": {
		"prefix": "bitwise",
		"body": [
			"#define SET(N, pos) N | (1 << (pos))",
			"#define isSET(N, pos) (N & (1 << (pos)) ? 1 : 0)",
			"#define CLR(N, pos) N & ~(1 << (pos));",
			"#define FLIP(N, pos) N ^ (1 << (pos));",
			"",
			"// 0-based indexing",
			"// Binary: 1 0 1 0 0 1 0 1",
			"// Index : 7 6 5 4 3 2 1 0",
		],
		"description": ""
	},
	"Check Brackets Balance": {
		"prefix": "bracket",
		"body": [
			"bool checkBrackets(string str) {",
			"    stack<char> stk;",
			"    for (int i = 0; i < (int) str.length(); ++i) {",
			"        if (str[i] == '(') stk.push('(');",
			"        else {",
			"            if (stk.empty() || stk.top() != '(') {",
			"                /*Condition: If the top bracket ",
			"                 * doesn't match with the closing one ",
			"                 * like: if '(' and ']' or ')' and ')'*/",
			"                return false;",
			"            } else stk.pop(); // If everything is okay, then dismiss that pair",
			"        }",
			"    }",
			"    if (stk.empty()) return true;",
			"",
			"    return false;",
			"}"
		],
		"description": ""
	},
	"Test Cases with count": {
		"prefix": "cases",
		"body": [
			"int t, tc = 0;",
			"cin >> t;",
			"while (t--) {",
			"    ",
			"    cout << \"Case \" << ++tc << \": \";",
			"    ",
			"}"
		],
		"description": ""
	},
	"Any Base Converter": {
		"prefix": "converter",
		"body": [
			"string digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";",
			"",
			"string fromDecimal(uint64_t n, uint16_t base) {",
			"    string num;",
			"    while (n > 0) {",
			"        num += digits[n % base];",
			"        n /= base;",
			"    }",
			"    reverse(num.begin(), num.end());",
			"    return num;",
			"}",
			"",
			"uint64_t toDecimal(const string &n, uint16_t base) {",
			"    uint64_t res = 0, multiplier = 1;",
			"    for (int i = (int) n.length() - 1; i >= 0; --i) {",
			"        char ch = n[i];",
			"        if (ch > '9') ch -= ch >= 'a' ? 39 : 7;",
			"        res += (ch - '0') * multiplier;",
			"        multiplier *= base;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"Date": {
		"prefix": "date",
		"body": [
			"",
			"$date$"
		],
		"description": ""
	},
	"Depth First Search : Iterative Version": {
		"prefix": "dfsi",
		"body": [
			"const int MXX = 5 + 1e5;",
			"bool vis[MXX];",
			"vector<int> G[MXX];",
			"",
			"void dfs(int s) {",
			"    stack<int> stk;",
			"    stk.push(s);",
			"    while (!stk.empty()) {",
			"        vis[s] = true;",
			"        int curr = stk.top();",
			"        stk.pop();",
			"        for (int next : G[curr]) {",
			"            if (!vis[next]) {",
			"                vis[next] = true;",
			"                stk.push(next);",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": ""
	},
	"Depth First Search : Recursive Version": {
		"prefix": "dfsr",
		"body": [
			"const int MXX = 5 + 1e5;",
			"",
			"bool vis[MXX];",
			"vector<int> G[MXX];",
			"",
			"void dfs(int s) {",
			"    vis[s] = true;",
			"    for (int next : G[s]) {",
			"        if (!vis[next]) dfs(next);",
			"    }",
			"}"
		],
		"description": ""
	},
	"Dijkstra's Algorithm for shortest path": {
		"prefix": "dijkstra",
		"body": [
			"const int MXX = 5 + 1e5;",
			"struct Node {",
			"    int vertex, weight;",
			"};",
			"",
			"int dist[MXX], parent[MXX];",
			"bool vis[MXX];",
			"vector<Node> G[MXX];",
			"",
			"void init() {",
			"    for (int i = 0; i < MXX; ++i) {",
			"        dist[i] = INT_MAX, parent[i] = -1, vis[i] = false;",
			"    }",
			"}",
			"",
			"void reset() {",
			"    init();",
			"    for (auto &i : G) i.clear();",
			"}",
			"",
			"vector<int> path(int dst) {",
			"    int curr = dst;",
			"    vector<int> path;",
			"    while (curr != -1) {",
			"        path.push_back(curr);",
			"        curr = parent[curr];",
			"    }",
			"    reverse(path.begin(), path.end());",
			"    return path;",
			"}",
			"",
			"struct cmp {",
			"    bool operator()(Node &a, Node &b) const {",
			"        return a.weight > b.weight;",
			"    }",
			"};",
			"",
			"void dijkstra(int s) {",
			"    dist[s] = 0, vis[s] = true;",
			"",
			"    priority_queue<Node, vector<Node>, cmp> PQ;",
			"    PQ.push({s, 0});",
			"",
			"    while (!PQ.empty()) {",
			"        Node curr = PQ.top();",
			"        PQ.pop();",
			"        int u = curr.vertex;",
			"        for (auto adj: G[u]) {",
			"            int v = adj.vertex;",
			"            int w = adj.weight;",
			"            if (!vis[v] && (dist[u] + w) < dist[v]) {",
			"                dist[v] = dist[u] + w;",
			"                parent[v] = u;",
			"                PQ.push({v, dist[v]});",
			"            }",
			"        }",
			"        vis[u] = true;",
			"    }",
			"}",
			""
		],
		"description": ""
	},
	"Number of smaller elements": {
		"prefix": "smaller",
		"body": [
			"/// Number of strictly smaller elements than `v`",
			"int smaller(vector<int> &A, int l, int r, int v) {",
			"    int L = l, R = r, res = l - 1;",
			"    while (L <= R) {",
			"        int mid = std::midpoint(L, R);",
			"        if (A[mid] < v) {",
			"            res = mid;",
			"            L = mid + 1;",
			"        } else",
			"            R = mid - 1;",
			"    }",
			"    return res - l + 1;",
			"}"
		],
		"description": ""
	},
	"Number of larger elements": {
		"prefix": "larger",
		"body": [
			"/// Number of strictly larger elements than `v`",
			"int larger(vector<int> &A, int l, int r, int v) {",
			"    int L = l, R = r, res = r + 1;",
			"    while (L <= R) {",
			"        int mid = std::midpoint(L, R);",
			"        if (A[mid] > v) {",
			"            res = mid;",
			"            R = mid - 1;",
			"        } else",
			"            L = mid + 1;",
			"    }",
			"    return r - res + 1;",
			"}"
		],
		"description": ""
	},
	"Number of digits of a number": {
		"prefix": "digits",
		"body": [
			"template<typename T = int>",
			"int digits(T n) {",
			"    return (int) log10(n) + 1;",
			"}"
		],
		"description": ""
	},
	"Muliply two integers under modulo M": {
		"prefix": "mulmod",
		"body": [
			"template <typename T = int>",
			"T mul_mod(T a, T b, T m) {",
			"    if (b == 0) {",
			"        return 0;",
			"    }",
			"",
			"    if (a > b) swap(a, b);",
			"    T res = 2 * mul_mod(a, b / 2, m) % m;",
			"    return b % 2 == 0 ? res % m : (res % m + a % m) % m;",
			"}",
		],
		"description": ""
	},
	"Generate power set": {
		"prefix": "gensubbin",
		"body": [
			"void print_(const vector<int> &v) {",
			"    for (const int &i: v) cout << i << \" \";",
			"    cout << \"\\n\";",
			"}",
			"",
			"void power_set(vector<int> &v, int n) {",
			"    vector<int> s;",
			"    for (int i = 0; i < (1 << n); ++i) {",
			"        for (int j = 0; j < n; ++j) {",
			"            if (i & 1 << j) s.push_back(v[j]);",
			"        }",
			"        print_(s);",
			"        s.clear();",
			"    }",
			"}"
		],
		"description": ""
	},
	"Custom hash function": {
		"prefix": "chash",
		"body": [
			"struct chash {",
			"    const uint64_t C = uint64_t(2e18 * numbers::pi) + 71;",
			"    const unsigned int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
			" ",
			"    uint64_t operator()(int64_t x) const {",
			"        return __builtin_bswap64((x ^ RANDOM) * C);",
			"    }",
			"};"
		],
		"description": ""
	},
	"Disjoint Set Union Data Structure": {
		"prefix": "disjoint",
		"body": [
			"class DisjointSet {",
			"private:",
			"    vector<int> parent;",
			"    size_t components, nodes;",
			"public:",
			"    explicit DisjointSet(size_t size) {",
			"        DisjointSet::nodes = size;",
			"        DisjointSet::components = 0;",
			"        parent.resize(nodes, -1);",
			"    }",
			"",
			"    void make_set(int u) {",
			"        parent[u] = u;",
			"        ++components;",
			"    }",
			"",
			"    void make_set() {",
			"        for (int i = 0; i < nodes; ++i) {",
			"            make_set(i);",
			"        }",
			"    }",
			"",
			"    size_t get_components_count() const {",
			"        return components;",
			"    }",
			"",
			"    int find(int u) {",
			"        if (u == parent[u]) return u;",
			"        return parent[u] = find(parent[u]);",
			"    }",
			"",
			"    void unite(int u, int v) {",
			"        int p = find(u);",
			"        int q = find(v);",
			"        if (p != q) {",
			"            parent[q] = p;",
			"            --components;",
			"        }",
			"    }",
			"",
			"    bool is_friend(int u, int v) {",
			"        return find(u) == find(v);",
			"    }",
			"",
			"};"
		],
		"description": ""
	},
	"Disjoint Set : Union by size": {
		"prefix": "disjoint_size",
		"body": [
			"class DisjointSet {",
			"private:",
			"    vector<int32_t> parent, comp_size;",
			"    size_t components, nodes;",
			"public:",
			"    explicit DisjointSet(size_t size) {",
			"        DisjointSet::nodes = size;",
			"        DisjointSet::components = 0;",
			"        parent.resize(nodes, -1);",
			"        comp_size.resize(nodes, -1);",
			"    }",
			"",
			"    void make_set(int32_t u) {",
			"        parent[u] = u;",
			"        comp_size[u] = 1;",
			"        ++components;",
			"    }",
			"",
			"    void make_set() {",
			"        for (int i = 0; i < nodes; ++i) {",
			"            make_set(i);",
			"        }",
			"    }",
			"",
			"    int32_t get_size(int32_t u) {",
			"        return comp_size[find(u)];",
			"    }",
			"",
			"    size_t get_components_count() const {",
			"        return components;",
			"    }",
			"",
			"",
			"    int32_t find(int32_t u) {",
			"        if (u == parent[u]) return u;",
			"        return parent[u] = find(parent[u]);",
			"    }",
			"",
			"    void unite(int32_t u, int32_t v) {",
			"        u = find(u), v = find(v);",
			"        if (u != v) {",
			"            if (comp_size[u] < comp_size[v]) swap(u, v);",
			"            parent[v] = u;",
			"            comp_size[u] += comp_size[v];",
			"            --components;",
			"        }",
			"    }",
			"};"
		],
		"description": ""
	},
	"Longest Common Subsequence": {
		"prefix": "lcs",
		"body": [
			"const int MX_N = 1005;",
			"string S1, S2;",
			"int dp[MX_N][MX_N];",
			"",
			"void init() {",
			"    memset(dp, -1, sizeof dp);",
			"}",
			"",
			"int LCS(int L1, int L2) {",
			"    if (L1 <= 0 || L2 <= 0) return 0;",
			"",
			"    if (dp[L1][L2] != -1) return dp[L1][L2];",
			"",
			"    if (S1[L1 - 1] == S2[L2 - 1]) {",
			"        return dp[L1][L2] = 1 + LCS(L1 - 1, L2 - 1);",
			"    } else {",
			"        return dp[L1][L2] = max(LCS(L1, L2 - 1), LCS(L1 - 1, L2));",
			"    }",
			"}"
		],
		"description": ""
	},
	"Longest Increasing Subsequence": {
		"prefix": "lis",
		"body": [
			"const int MX_N = 1005;",
			"int dp[MX_N];",
			"",
			"int LIS(const vector<int> &a, int n, int i) {",
			"    if (dp[i] != -1) return dp[i];",
			"",
			"    int ans = 0;",
			"    for (int j = i + 1; j < n; ++j) {",
			"        if (a[j] > a[i]) {",
			"            ans = max(ans, LIS(a, n, j));",
			"        }",
			"    }",
			"    return dp[i] = 1 + ans;",
			"}",
			"",
			"int LIS(const vector<int> &a, int n) {",
			"    int ans = 0;",
			"    memset(dp, -1, sizeof dp);",
			"    for (int i = 0; i < n; ++i) {",
			"        ans = max(ans, LIS(a, n, i));",
			"    }",
			"    return ans;",
			"}"
		],
		"description": ""
	},
	"BFS in a class": {
		"prefix": "bfs_class",
		"body": [
			"class bfs {",
			"public:",
			"    vector<int> dist, par;",
			"    vector<vector<int>> adj;",
			"",
			"    void add_edge(int u, int v) {",
			"        adj[u].push_back(v);",
			"    }",
			"",
			"    explicit bfs(int n) {",
			"        adj.resize(n), dist.resize(n, -1), par.resize(n, -1);",
			"    }",
			"",
			"    ~bfs() {",
			"        adj.clear(), dist.clear(), par.clear();",
			"    }",
			"",
			"    void traverse(vector<int> s) {",
			"        queue<int> Q;",
			"        for (auto i: s)",
			"            Q.push(i), dist[i] = 0, par[i] = -1;",
			"",
			"        while (!Q.empty()) {",
			"            int x = Q.front();",
			"            Q.pop();",
			"            for (int c: adj[x]) {",
			"                if (dist[c] == -1)",
			"                    dist[c] = dist[x] + 1, par[c] = x, Q.push(c);",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": ""
	},
	"Shuffle a container": {
		"prefix": "shuffle",
		"body": [
			"template<typename T>",
			"void shuffle(T &c, int scale) {",
			"    size_t N = c.size();",
			"    srand(time(nullptr));",
			"    for (int i = 1; i <= scale; ++i) {",
			"        int L = rand() % N, R = rand() % N;",
			"        if (L > R) swap(L, R);",
			"        swap(c[L], c[R]);",
			"    }",
			"}"
		],
		"description": ""
	},
	"Segment Tree with Lazy Propagation": {
		"prefix": "lazysegtree",
		"body": [
			"#define LAZY_DEFAULT_VAL 0",
			"template<typename T>",
			"class SegmentTree {",
			"private:",
			"    vector<T> tree, lazy;",
			"    int N;",
			"    pair<T, function<T(T, T)>> query_type;",
			"",
			"    void propagate(int node, int tL, int tR, T v) {",
			"        tree[node] += (tR - tL + 1) * v;",
			"        if (tL != tR) {",
			"            int left = 2 * node, right = 2 * node + 1;",
			"            lazy[left] += v;",
			"            lazy[right] += v;",
			"        }",
			"    }",
			"",
			"    void bb(int node, int tL, int tR) {",
			"        if (tL == tR) {",
			"            tree[node] = a[tL];",
			"            return;",
			"        }",
			"        int mid = (tL + tR) / 2;",
			"        int left = 2 * node, right = 2 * node + 1;",
			"        bb(left, tL, mid);",
			"        bb(right, mid + 1, tR);",
			"        tree[node] = query_type.second(tree[left], tree[right]);",
			"    }",
			"",
			"    T qq(int node, int tL, int tR, int qL, int qR) {",
			"        if (tL > tR) return query_type.first;",
			"",
			"        if (lazy[node] != LAZY_DEFAULT_VAL) {",
			"            propagate(node, tL, tR, lazy[node]);",
			"            lazy[node] = LAZY_DEFAULT_VAL;",
			"        }",
			"        if (tR < qL || tL > qR) return query_type.first;",
			"",
			"        if (tL >= qL && tR <= qR) return tree[node];",
			"        ",
			"        int mid = (tL + tR) / 2;",
			"        int left = 2 * node, right = 2 * node + 1;",
			"        return query_type.second(qq(left, tL, mid, qL, qR),",
			"                                 qq(right, mid + 1, tR, qL, qR));",
			"    }",
			"",
			"    void uu(int node, int tL, int tR, int qL, int qR, T v) {",
			"        if (tL > tR) return;",
			"",
			"        if (lazy[node] != LAZY_DEFAULT_VAL) {",
			"            propagate(node, tL, tR, lazy[node]);",
			"            lazy[node] = LAZY_DEFAULT_VAL;",
			"        }",
			"        if (tR < qL || tL > qR) return;",
			"",
			"        if (tL >= qL && tR <= qR) {",
			"            propagate(node, tL, tR, v);",
			"            return;",
			"        }",
			"",
			"        int mid = (tL + tR) / 2;",
			"        int left = 2 * node, right = 2 * node + 1;",
			"        uu(left, tL, mid, qL, qR, v);",
			"        uu(right, mid + 1, tR, qL, qR, v);",
			"        tree[node] = query_type.second(tree[left], tree[right]);",
			"    }",
			"",
			"public:",
			"    vector<T> a;",
			"",
			"    explicit SegmentTree(int N, pair<T, function<T(T, T)>> query_type) {",
			"        SegmentTree::N = N;",
			"        a.resize(N);",
			"        tree.resize(4 * N);",
			"        lazy.resize(4 * N, LAZY_DEFAULT_VAL);",
			"        SegmentTree::query_type = query_type;",
			"    }",
			"",
			"    ~SegmentTree() {",
			"        a.clear();",
			"        tree.clear();",
			"        lazy.clear();",
			"        SegmentTree::N = 0;",
			"    }",
			"",
			"    [[nodiscard]] int size() const noexcept {",
			"        return N;",
			"    }",
			"",
			"    T query(int qL, int qR) {",
			"        return qq(1, 0, N - 1, qL, qR);",
			"    }",
			"",
			"    void build() {",
			"        bb(1, 0, N - 1);",
			"    }",
			"",
			"    void update(int qL, int qR, T v) {",
			"        uu(1, 0, N - 1, qL, qR, v);",
			"    }",
			"};",
			"",
			"#define RET_VALUE 0",
			"template<typename T>",
			"pair<T, function<T(T, T)>> query_type = {RET_VALUE, [](T L, T R) -> T {",
			"    return L + R;",
			"}",
			"};"
		],
		"description": ""
	},
	"Dynamically Allocate a 2D Array": {
		"prefix": "dynamic2D",
		"body": [
			"#define A(i, j) *(A + i * N + j)",
			"",
			"const int N = 2, M = 3;",
			"int *A = new int[N * M];"
		],
		"description": ""
	},
	"Measure Execution Time": {
		"prefix": "exectime",
		"body": [
			"auto bgn = chrono::high_resolution_clock::now();",
			"",
			"// Code goes here",
			"",
			"auto end = chrono::high_resolution_clock::now();",
			"auto time = chrono::duration_cast<chrono::milliseconds>(end - bgn);",
			"cout << time.count() << \" ms\\n\";"
		],
		"description": ""
	},
	"Factorial of a number": {
		"prefix": "factorial",
		"body": [
			"int64_t factorial(int64_t n) {",
			"    if (n == 0) return 1LL;",
			"    return n * factorial(n - 1);",
			"}"
		],
		"description": ""
	},
	"Integer Factorization of a number": {
		"prefix": "factorization",
		"body": [
			"",
			"vector<int64_t> factorization(int64_t n) {",
			"    vector<int64_t> pf;",
			"    while (n % 2 == 0) pf.push_back(2), n /= 2;",
			"",
			"    for (int64_t i = 3; i * i <= n; i += 2)",
			"        while (n % i == 0) pf.push_back(i), n /= i;",
			"",
			"    if (n > 1) pf.push_back(n);",
			"    return pf;",
			"}"
		],
		"description": ""
	},
	"Efficient integer factorization": {
		"prefix": "factorizationE",
		"body": [
			"const int MX_N = 1e8;",
			"bitset<MX_N + 1> isPrime;",
			"vector<int> P = {2};",
			"",
			"void sieve() {",
			"    // false = prime, true = not prime",
			"    isPrime[0] = isPrime[1] = true;",
			"    for (int i = 2; 1LL * i * i <= MX_N; ++i) {",
			"        if (!isPrime[i]) {",
			"            for (int64_t j = 1LL * i * i; j <= MX_N; j += i) {",
			"                isPrime[j] = true;",
			"            }",
			"        }",
			"    }",
			"    for (int i = 3; i <= MX_N; i += 2)",
			"        if (!isPrime[i])",
			"            P.push_back(i);",
			"}",
			"",
			"vector<int64_t> factorize(int64_t n) {",
			"    vector<int64_t> pf;",
			"    int sqN = sqrt(n);",
			"    for (int i = 0; i < P.size() && P[i] <= sqN; ++i) {",
			"        if (n % P[i] == 0) {",
			"            while (n % P[i] == 0)",
			"                pf.push_back(P[i]), n /= P[i];",
			"            sqN = sqrt(n);",
			"        }",
			"    }",
			"    if (n > 1) pf.push_back(n);",
			"    return pf;",
			"}"
		],
		"description": ""
	},
	"Integer factorization using sieve": {
		"prefix": "factorize",
		"body": [
			"const int MX_N = 1e6;",
			"int PF[MX_N + 1];",
			"",
			"void sieve() {",
			"    memset(PF, -1, sizeof PF);",
			"    for (int i = 2; i <= MX_N; ++i) {",
			"        if (PF[i] == -1) {",
			"            for (int64_t j = 1LL * i * i; j <= MX_N; j += i) PF[j] = i;",
			"            PF[i] = i;",
			"        }",
			"    }",
			"}",
			"",
			"vector<int> factorize(int n) {",
			"    vector<int> pf;",
			"    while (n != 1) {",
			"        pf.push_back(PF[n]);",
			"        n /= PF[n];",
			"    }",
			"    sort(pf.begin(), pf.end());",
			"    return pf;",
			"}"
		],
		"description": ""
	},
	"Factors of a number": {
		"prefix": "facts",
		"body": [
			"vector<int64_t> factors(int64_t n) {",
			"    vector<int64_t> f;",
			"    for (int i = 1; 1LL * i * i <= n; ++i) {",
			"        if (n % i == 0) {",
			"            f.push_back(i);",
			"            if (i * i != n)",
			"                f.push_back(n / i);",
			"        }",
			"    }",
			"    sort(f.begin(), f.end());",
			"    return f;",
			"}",
		],
		"description": ""
	},
	"Trailing zeros of factorial": {
		"prefix": "factzeros",
		"body": [
			"int64_t fact_trailing_zeros(int64_t n) {",
			"    int64_t count = 0;",
			"    for (int64_t i = 5; i <= n; i *= 5)",
			"        count += (n / i);",
			"    return count;",
			"}"
		],
		"description": ""
	},
	"Input an Arrray": {
		"prefix": "garr",
		"body": [
			"int n;",
			"cin >> n;",
			"int a[n];",
			"for (int &i : a) cin >> i;"
		],
		"description": ""
	},
	"Select an entire container": {
		"prefix": "all",
		"body": [
			"$a.begin(), $a.end()$0"
		],
		"description": ""
	},
	"Select an entire container : reversed": {
		"prefix": "allr",
		"body": [
			"$a.rbegin(), $a.rend()$0"
		],
		"description": ""
	},
	"Generate power set recursively": {
		"prefix": "gensub",
		"body": [
			"void print_(int n, int mask) {",
			"    for (int i = 0; i < n; ++i)",
			"        if (mask & (1 << i)) cout << i << \" \";",
			"    cout << '\\n';",
			"}",
			"",
			"void power_set(int n, int i = 0, int mask = 0) {",
			"    if (i == n) {",
			"        print_(n, mask);",
			"        return;",
			"    }",
			"    power_set(n, i + 1, mask | (1 << i));",
			"    power_set(n, i + 1, mask);",
			"}",
		],
		"description": ""
	},
	"Knuth-Morris-Pratt Algorithm for patterrn maching": {
		"prefix": "kmp",
		"body": [
			"vector<int> buildLpsArray(string pat) {",
			"    int len = (int) pat.length();",
			"    vector<int> lps(len);",
			"    int idx = 0;",
			"    for (int i = 1; i < len;) {",
			"        if (pat[i] == pat[idx]) lps[i] = idx + 1, ++idx, ++i;",
			"        else if (idx != 0) idx = lps[idx - 1];",
			"        else lps[i] = idx, ++i;",
			"    }",
			"    return lps;",
			"}",
			"",
			"vector<int> KMP(string text, string pat) {",
			"    vector<int> lps = buildLpsArray(pat), match;",
			"    int j = 0, i = 0, tlen = (int) text.length(), plen = (int) pat.length();",
			"    while (i < tlen) {",
			"        if (text[i] == pat[j]) ++i, ++j;",
			"        else if (j != 0) j = lps[j - 1];",
			"        else ++i;",
			"",
			"        if (j == plen) {",
			"            match.push_back(i - plen);",
			"            j = lps[j - 1];",
			"        }",
			"    }",
			"    return match;",
			"}"
		],
		"description": ""
	},
	"The 0/1 Knapsack Problem": {
		"prefix": "knapsack",
		"body": [
			"int dp[2005][2005];",
			"//    [cap][n]",
			"",
			"void init() {",
			"    for (auto &i : dp) {",
			"        for (int &j : i) {",
			"            j = -1;",
			"        }",
			"    }",
			"}",
			"",
			"int knapsack(vector<int> &W, vector<int> &P, int cap, int n) {",
			"",
			"    if (cap <= 0 || n <= 0) {",
			"        return 0;",
			"    }",
			"    if (dp[cap][n] != -1) return dp[cap][n];",
			"",
			"    if (W[n - 1] <= cap) {",
			"        return dp[cap][n] = max(P[n - 1] + knapsack(W, P, cap - W[n - 1], n - 1),",
			"                                knapsack(W, P, cap, n - 1));",
			"    } else {",
			"        return dp[cap][n] = knapsack(W, P, cap, n - 1);",
			"    }",
			"",
			"}",
			""
		],
		"description": ""
	},
	"Least Common Multiple of two integers": {
		"prefix": "lcm",
		"body": [
			"int64_t lcm(int64_t a, int64_t b) {",
			"    return (a / __gcd(a, b)) * b;",
			"}"
		],
		"description": ""
	},
	"DP : Minimum Coin Change": {
		"prefix": "mincoin",
		"body": [
			"const int MXX = 1000000;",
			"int64_t table[MXX + 1];",
			"",
			"int64_t coinChange(vector<int> &coins, int amount) {",
			"    memset(table, 0, sizeof table);",
			"    table[0] = 0;",
			"    for (int i = 1; i <= amount; ++i) {",
			"        int64_t mn = INT_MAX;",
			"        for (auto j : coins) {",
			"            if (i >= j)",
			"                mn = min(mn, 1 + table[i - j]);",
			"        }",
			"        table[i] = mn;",
			"    }",
			"",
			"    return table[amount] == INT_MAX ? -1 : table[amount];",
			"}",
			""
		],
		"description": ""
	},
	"Combinations": {
		"prefix": "ncr",
		"body": [
			"const int mx = 101;",
			"ll dp[mx][mx];",
			"ll nCr(ll n, ll r) {",
			"    if (dp[n][r] != -1) return dp[n][r];",
			"    if (r == 0 || r == n) return dp[n][r] = 1;",
			"    return dp[n][r] = nCr(n - 1, r - 1) + nCr(n - 1, r);",
			"}",
			"",
			"void init() {",
			"    for (auto &i : dp)",
			"        for (ll &j : i) j = -1;",
			"}"
		],
		"description": ""
	},
	"Number of divisors of a number": {
		"prefix": "nod",
		"body": [
			"const int N = 1000001;",
			"int nod[N + 1];",
			"void generate_nod() {",
			"    for (int i = 1; i <= N; ++i) {",
			"        for (int j = i; j <= N; j += i) {",
			"            nod[j] += 1;",
			"        }",
			"    }",
			"}"
		],
		"description": ""
	},
	"Sparse Table": {
		"prefix": "sparse",
		"body": [
			"const int N = 100001, LG = 18;",
			"int st[N][LG];",
			"",
			"void sparse_table(vector<int>& a, int n) {",
			"    for (int i = 0; i < n; ++i) {",
			"        st[i][0] = a[i];",
			"    }",
			"",
			"    for (int j = 1; j < LG; ++j) {",
			"        for (int i = 0; i + (1 << j) - 1 < n; ++i) {",
			"            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
			"        }",
			"    }",
			"}",
			"",
			"int rmq(int L, int R) {",
			"    int lg = __lg(R - L + 1);",
			"    return min(st[L][lg], st[R - (1 << lg) + 1][lg]);",
			"}"
		],
		"description": "Sparse Table"
	},
	"Lowest Common Ancestor": {
		"prefix": "lca",
		"body": [
			"vector<int> dist;",
			"vector<vector<int>> up;",
			"vector<vector<int>> adj;",
			"int lg = -1;",
			"",
			"void dfs(int u, int p = -1) {",
			"    up[u][0] = p;",
			"    for (auto v : adj[u]) {",
			"        if (dist[v] != -1) continue;",
			"        dist[v] = 1 + dist[u];",
			"        dfs(v, u);",
			"    }",
			"}",
			"",
			"void pre_process(int root, int n) {",
			"    assert(lg != -1);",
			"    dist[root] = 0;",
			"    dfs(root);",
			"    for (int i = 1; i < lg; ++i) {",
			"        for (int j = 1; j <= n; ++j) {// 1-based graph",
			"            int p = up[j][i - 1];",
			"            if (p == -1) continue;",
			"            up[j][i] = up[p][i - 1];",
			"        }",
			"    }",
			"}",
			"",
			"int get_lca(int u, int v) {",
			"    if (dist[u] > dist[v])",
			"        swap(u, v);",
			"",
			"    int dif = dist[v] - dist[u];",
			"    while (dif > 0) {",
			"        int lg = __lg(dif);",
			"        v = up[v][lg];",
			"        dif -= (1 << lg);",
			"    }",
			"    if (u == v)",
			"        return u;",
			"",
			"    for (int i = lg - 1; i >= 0; --i) {",
			"        if (up[u][i] == up[v][i]) continue;",
			"        u = up[u][i];",
			"        v = up[v][i];",
			"    }",
			"    return up[u][0];",
			"}",
			"",
			"int get_kth_ancestor(int v, int k) {",
			"    while (k > 0) {",
			"        int lg = __lg(k);",
			"        v = up[v][lg];",
			"        k -= (1 << lg);",
			"    }",
			"    return v;",
			"}",
		],
		"description": ""
	},
	"Möbius Function Sieve": {
		"prefix": "mobius",
		"body": [
			"const int MX_N = 1e6;",
			"int spf[MX_N + 1];",
			"int mu[MX_N + 1];",
			"",
			"void mobius() {",
			"    memset(spf, -1, sizeof spf);",
			"    for (int i = 2; i <= MX_N; ++i) {",
			"        if (spf[i] == -1) {",
			"            for (int64_t j = 1LL * i * i; j <= MX_N; j += i) spf[j] = i;",
			"            spf[i] = i;",
			"        }",
			"    }",
			"    mu[1] = 1;",
			"    for (int i = 2; i <= MX_N; ++i) {",
			"        vector<int> pf;",
			"        int n = i;",
			"        while (n != 1) {",
			"            pf.push_back(spf[n]);",
			"            n /= spf[n];",
			"        }",
			"        int k = (int) pf.size();",
			"        sort(pf.begin(), pf.end());",
			"        pf.erase(unique(pf.begin(), pf.end()), pf.end());",
			"        if (k != (int) pf.size()) {",
			"            mu[i] = 0;",
			"            continue;",
			"        }",
			"        mu[i] = (k & 1) ? -1 : 1;",
			"    }",
			"}",
		],
		"description": ""
	},
	"Möbius Function": {
		"prefix": "mobius_sqrt",
		"body": [
			"int mobius(int64_t n) {",
			"    int k = 0;",
			"    for (int64_t i = 2; i * i <= n; ++i) {",
			"        if (n % i == 0) {",
			"            if (n % (i * i) == 0) return 0;",
			"            n /= i;",
			"            ++k;",
			"        }",
			"    }",
			"    return k & 1 ? 1 : -1;",
			"}",
		],
		"description": ""
	},
	"Permutaions": {
		"prefix": "npr",
		"body": [
			"const int mx = 101;",
			"ll dp[mx][mx];",
			"",
			"ll nCr(ll n, ll r) {",
			"    if (dp[n][r] != -1) return dp[n][r];",
			"    if (r == 0 || r == n) return dp[n][r] = 1;",
			"    return dp[n][r] = nCr(n - 1, r - 1) + nCr(n - 1, r);",
			"}",
			"",
			"void init() {",
			"    for (auto &i : dp)",
			"        for (ll &j : i) j = -1;",
			"}",
			"",
			"ll nPr(ll n, ll r) {",
			"    ll rF = 1, i = 1;",
			"    while (i++ < r) rF *= i;",
			"",
			"    return nCr(n, r) * rF;",
			"}"
		],
		"description": ""
	},
	"Power Function": {
		"prefix": "power",
		"body": [
			"int64_t power(int64_t b, int e) {",
			"    int64_t res = 1;",
			"    while (e > 0) {",
			"        if (e & 1) res *= b;",
			"        e >>= 1, b *= b;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"Directional array": {
		"prefix": "dir_arr",
		"body": [
			"const int dx[] = {-1, +1, +0, +0, -1, -1, +1, +1};",
			"const int dy[] = {+0, +0, -1, +1, -1, +1, -1, +1};"
		],
		"description": ""
	},
	"Utilities": {
		"prefix": "utils",
		"body": [
			"template<typename type>ostream &operator<<(ostream &out, const vector<type> &v) {for (const type &i: v) out << i << ' ';return out;}",
			"template<typename type>ostream &operator<<(ostream &out, const vector<vector<type>> &v) {for (const vector<type> &i: v) out << i << '\\n';return out;}",
			"template<typename type>ostream &operator<<(ostream &out, const set<type> &s) {for (const type &i: s) out << i << ' ';return out;}",
			"template<typename type>ostream &operator<<(ostream &out, const multiset<type> &ms) {for (const type &i: ms) out << i << ' ';return out;}",
			"template<typename A, typename B>ostream &operator<<(ostream &out, const map<A, B> &mp) {for (const pair<const A, B> &i: mp) {out << '[' << i.first << \": \" << i.second << ']' << '\\n';}return out;}",
			"template<typename type>ostream &operator<<(ostream &out, const queue<type> &q) {queue<type> r = q;while (!r.empty()) out << r.front() << ' ', r.pop();return out;}",
			"template<typename type>ostream &operator<<(ostream &out, const stack<type> &s) {stack<type> t = s;while (!t.empty()) out << t.top() << ' ', t.pop();return out;}",
			"template<typename type>istream &operator>>(istream &in, vector<type> &v) {for (type &i: v) in >> i;return in;}",
			"template<typename type>istream &operator>>(istream &in, vector<vector<type>> &v) {for (vector<type> &i: v) in >> i;return in;}",
			"template<typename type>vector<int> operator+(const vector<type> &v, const vector<type> &w) {vector<type> r = v;for (const type &i: w) r.push_back(i);return r;}",
			"template<typename type>set<int> operator|(const set<type> &s, const set<type> &t) {set<type> r;set_union(s.begin(), s.end(), t.begin(), t.end(), inserter(r, r.end()));return r;}",
			"template<typename type>set<int> operator&(const set<type> &s, const set<type> &t) {set<type> r;set_intersection(s.begin(), s.end(), t.begin(), t.end(), inserter(r, r.end()));return r;}",
			""
		],
		"description": ""
	},
	"Segment tree with point update": {
		"prefix": "segtree",
		"body": [
			"const int MX_N = 5 + 1e5;",
			"int a[MX_N], tree[4 * MX_N];",
			"",
			"",
			"void build(int node, int tL, int tR) {",
			"    if (tL == tR) {",
			"        tree[node] = a[tL];",
			"        return;",
			"    }",
			"    int mid = (tL + tR) / 2;",
			"    int left = 2 * node, right = 2 * node + 1;",
			"    build(left, tL, mid);",
			"    build(right, mid + 1, tR);",
			"    tree[node] = min(tree[left], tree[right]);",
			"}",
			"",
			"void update(int node, int tL, int tR, int i, int v) {",
			"    if (tL >= i && tR <= i) {",
			"        tree[node] = v;",
			"        return;",
			"    }",
			"    if (tR < i || tL > i) return;",
			"",
			"    int mid = (tL + tR) / 2;",
			"    int left = 2 * node, right = 2 * node + 1;",
			"    update(left, tL, mid, i, v);",
			"    update(right, mid + 1, tR, i, v);",
			"    tree[node] = min(tree[left], tree[right]);",
			"}",
			"",
			"int query(int node, int tL, int tR, int qL, int qR) {",
			"    if (tL >= qL && tR <= qR) {",
			"        return tree[node];",
			"    }",
			"    if (tR < qL || tL > qR) {",
			"        return INT_MAX;",
			"    }",
			"    int mid = (tL + tR) / 2;",
			"    int QL = query(2 * node, tL, mid, qL, qR);",
			"    int QR = query(2 * node + 1, mid + 1, tR, qL, qR);",
			"    return min(QL, QR);",
			"}"
		],
		"description": ""
	},
	"Namespace : Sorting Algorithms": {
		"prefix": "sortingalgos",
		"body": [
			"namespace sorting_algorithms {",
			"    void heapify(vector<int> &A, int n, int i) {",
			"        int mx = i, l = 2 * i + 1, r = 2 * i + 2;",
			"",
			"        if (l < n && A[l] > A[mx]) mx = l;",
			"        if (r < n && A[r] > A[mx]) mx = r;",
			"        if (mx != i) {",
			"            swap(A[i], A[mx]);",
			"            heapify(A, n, mx);",
			"        }",
			"    }",
			"",
			"    void heap_sort(vector<int> &A, int n) {",
			"        for (int i = n / 2 - 1; i >= 0; --i)",
			"            heapify(A, n, i);",
			"",
			"        for (int i = n - 1; i >= 0; --i) {",
			"            swap(A[0], A[i]);",
			"            heapify(A, i, 0);",
			"        }",
			"    }",
			"",
			"    void merge(vector<int> &A, int L, int R) {",
			"        int mid = (L + R) / 2;",
			"        vector<int> merged(R - L + 1);",
			"        int i = L, j = mid + 1, k = 0;",
			"        for (; i <= mid && j <= R;) {",
			"            if (A[i] < A[j]) {",
			"                merged[k++] = A[i];",
			"                ++i;",
			"            } else {",
			"                merged[k++] = A[j];",
			"                ++j;",
			"            }",
			"        }",
			"        while (i <= mid) merged[k++] = A[i], ++i;",
			"        while (j <= R) merged[k++] = A[j], ++j;",
			"        for (auto m: merged) A[L++] = m;",
			"",
			"    }",
			"",
			"    void merge_sort(vector<int> &A, int L, int R) {",
			"        int size = R - L + 1;",
			"        if (size == 1) {",
			"            return;",
			"        }",
			"        int mid = (L + R) / 2;",
			"        merge_sort(A, L, mid);",
			"        merge_sort(A, mid + 1, R);",
			"        merge(A, L, R);",
			"    }",
			"",
			"    void merge_sort(vector<int> &A) {",
			"        merge_sort(A, 0, (int) A.size() - 1);",
			"    }",
			"}",
			"using namespace sorting_algorithms;"
		],
		"description": ""
	},
	"Output a vector": {
		"prefix": "out_vec",
		"body": [
			"template<typename Tp>",
			"void output_vector(const vector<Tp>& a) {",
			"  for (Tp& i : a) {",
			"    cout << i << \" \";",
			"  }",
			"  cout << '\\n';",
			"}",
		],
		"description": "Output a vector"
	},
	"Output the contents of a container": {
		"prefix": "output",
		"body": [
			"for (int i = 0; i < ${n}; ++i) {",
			"  cout << ${a}[i] << \" \";",
			"}",
			"cout << '\\n';",
			"$0",
		],
		"description": ""
	},
	"Input a vector": {
		"prefix": "invec",
		"body": [
			"int n;",
			"cin >> n;",
			"vector<int> $a(n);",
			"for (int i = 0; i < n; ++i) {",
			"    cin >> $a[i];",
			"}",
			"$0",
		],
		"description": ""
	},
	"Input a graph": {
		"prefix": "ingraph",
		"body": [
			"    int n, m;",
			"    cin >> n >> m;",
			"",
			"    vector<vector<int>> adj(n);",
			"    for (int i = 0; i < m; ++i) {",
			"        int u, v;",
			"        cin >> u >> v;",
			"        --u, --v;",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"    }",
		],
		"description": ""
	},
	"File I/O": {
		"prefix": "fileIO",
		"body": [
			"#ifdef LOCAL",
			"    freopen(\"in.txt\", \"r\", stdin);",
			"    freopen(\"out.txt\", \"w\", stdout);",
			"#endif",
			""
		],
		"description": ""
	},
	"Rabin - Karp pattern matching algorighm": {
		"prefix": "rabinkarp",
		"body": [
			"const int base = 347, mod = 1000000007;",
			"",
			"int64_t get_hash(const string& s, int m) {",
			"    int64_t hash = 0, exp = 1;",
			"    for (int i = m - 1; i >= 0; --i) {",
			"        hash = (hash % mod + (s[i] * exp) % mod) % mod;",
			"        exp = (exp * base) % mod;",
			"    }",
			"    return hash;",
			"}",
			"vector<int> rabin_karp(const string& s, const string& p) {",
			"    vector<int> pos;",
			"    int n = s.length(), m = p.length();",
			"    if (n < m || m == 0 || n == 0)",
			"        return pos;",
			"",
			"    int64_t exp = 1;",
			"    for (int i = 1; i <= m - 1; ++i) {",
			"        exp = (exp * base) % mod;",
			"    }",
			"",
			"    int64_t h_txt = get_hash(s, m);",
			"    int64_t h_pat = get_hash(p, m);",
			"",
			"    if (h_txt == h_pat) {",
			"        pos.push_back(0);",
			"    }",
			"    for (int i = m; i < n; ++i) {",
			"        h_txt = (h_txt - (exp * s[i - m]) % mod) % mod;",
			"        h_txt = (h_txt + mod) % mod;",
			"        h_txt = (h_txt * base) % mod;",
			"        h_txt = (h_txt + s[i]) % mod;",
			"",
			"        if (h_txt == h_pat) {",
			"            pos.push_back(i - m + 1);",
			"        }",
			"    }",
			"    return pos;",
			"}",
		],
		"description": ""
	},
	"Segmented Sieve of Eratosthenes": {
		"prefix": "segmented_sieve",
		"body": [
			"vector<bool> segmented_sieve(int64_t L, int64_t R) {",
			"    int64_t LIMIT = 1 + sqrt(R);",
			"    vector<bool> mark(LIMIT);",
			"    vector<int64_t> primes;",
			"    for (int64_t i = 2; i < LIMIT; ++i) {",
			"        if (!mark[i]) {",
			"            primes.push_back(i);",
			"            for (int64_t j = i * i; j < LIMIT; j += i)",
			"                mark[j] = true;",
			"        }",
			"    }",
			"    vector<bool> is_prime(R - L + 1, true);",
			"    for (auto &i: primes)",
			"        for (int64_t j = max(i * i, (L + i - 1) / i * i); j <= R; j += i)",
			"            is_prime[j - L] = false;",
			"    is_prime[0] = L != 1;",
			"    return is_prime;",
			"}"
		],
		"description": ""
	},
	"Polynomial Hashing Utility": {
		"prefix": "phash",
		"body": [
			"struct polynomial_hash {",
			"    std::array<int, 2> base{47, 59};",
			"    std::array<int, 2> mod{1000000007, 1000000033};",
			"    std::array<std::vector<int>, 2> f_hash, r_hash;",
			"    std::array<std::vector<int>, 2> expo;",
			"    std::string s;",
			"    int size = 0;",
			"    using s_it = std::string::iterator;",
			"",
			"    polynomial_hash() = default;",
			"",
			"    polynomial_hash(s_it st, s_it ed) {",
			"        polynomial_hash::init(st, ed);",
			"    }",
			"    explicit polynomial_hash(std::string s) {",
			"        polynomial_hash::init(s.begin(), s.end());",
			"    }",
			"    polynomial_hash(s_it st, s_it ed, std::initializer_list<int> base, std::initializer_list<int> mod) {",
			"        for (const int& i : {0, 1}) {",
			"            polynomial_hash::base[i] = *(base.begin() + i);",
			"            polynomial_hash::mod[i] = *(mod.begin() + i);",
			"        }",
			"        polynomial_hash::init(st, ed);",
			"    }",
			"",
			"    void set_string(std::string s) {",
			"        polynomial_hash::init(s.begin(), s.end());",
			"    }",
			"",
			"    void init(s_it st, s_it ed) {",
			"        polynomial_hash::s = std::string(st, ed);",
			"        polynomial_hash::size = (int) distance(st, ed);",
			"    }",
			"",
			"    void resize(int i = 0) {",
			"        polynomial_hash::f_hash[i].resize(size, 0);",
			"        polynomial_hash::r_hash[i].resize(size, 0);",
			"        polynomial_hash::expo[i].resize(size + 1, 1);",
			"    }",
			"",
			"    void compute_expo(int i = 0) {",
			"        for (int j = 1; j <= polynomial_hash::size; ++j) {",
			"            expo[i][j] = int((1LL * expo[i][j - 1] * base[i]) % mod[i]);",
			"        }",
			"    }",
			"    void compute_single_hash(int i = 0) {",
			"        resize(i);",
			"        compute_expo(i);",
			"        int fh = 0, rh = 0;",
			"        for (int j = 0; j < polynomial_hash::size; ++j) {",
			"            fh = int((1LL * fh * base[i] + s[j]) % mod[i]);",
			"            rh = int((1LL * rh * base[i] + s[polynomial_hash::size - j - 1]) % mod[i]);",
			"            polynomial_hash::f_hash[i][j] = fh;",
			"            polynomial_hash::r_hash[i][polynomial_hash::size - 1 - j] = rh;",
			"        }",
			"    }",
			"",
			"    void compute_double_hash() {",
			"        compute_single_hash(0);",
			"        compute_single_hash(1);",
			"    }",
			"",
			"    uint64_t get_single_f_hash(int l, int r, int i = 0) {",
			"        int h = 0;",
			"        h = int((f_hash[i][r] - (l > 0 ? 1LL * f_hash[i][l - 1] * expo[i][r - l + 1] : 0)) % mod[i]);",
			"        return h < 0 ? h += mod[i] : h;",
			"    }",
			"",
			"    uint64_t get_double_f_hash(int l, int r) {",
			"        return (polynomial_hash::get_single_f_hash(l, r, 0) << 32) ^ polynomial_hash::get_single_f_hash(l, r, 1);",
			"    }",
			"",
			"    uint64_t get_single_r_hash(int l, int r, int i = 0) {",
			"        int h = 0;",
			"        h = int((r_hash[i][l] - (r < size - 1 ? 1LL * r_hash[i][r + 1] * expo[i][r - l + 1] : 0)) % mod[i]);",
			"        return h < 0 ? h += mod[i] : h;",
			"    }",
			"",
			"    uint64_t get_double_r_hash(int l, int r) {",
			"        return (polynomial_hash::get_single_r_hash(l, r, 0) << 32) ^ polynomial_hash::get_single_r_hash(l, r, 1);",
			"    }",
			"",
			"    int length() const {",
			"        return polynomial_hash::size;",
			"    }",
			"};",
		],
		"description": "Polynomial Hashing Utility"
	},
	"Polynomial Hashing Utility: Unsigned": {
		"prefix": "uhash",
		"body": [
			"struct unsigned_hash {",
			"    std::array<uint64_t, 2> base{47, 59};",
			"    std::array<std::vector<uint64_t>, 2> f_hash, r_hash;",
			"    std::array<std::vector<uint64_t>, 2> expo;",
			"    std::string s;",
			"    int size = 0;",
			"    using s_it = std::string::iterator;",
			"",
			"    unsigned_hash() = default;",
			"",
			"    explicit unsigned_hash(std::string s) {",
			"        unsigned_hash::init(s.begin(), s.end());",
			"    }",
			"    unsigned_hash(s_it st, s_it ed) {",
			"        unsigned_hash::init(st, ed);",
			"    }",
			"",
			"    unsigned_hash(s_it st, s_it ed, std::initializer_list<uint64_t> base, std::initializer_list<uint64_t> mod) {",
			"        for (const int& i : {0, 1}) {",
			"            unsigned_hash::base[i] = *(base.begin() + i);",
			"        }",
			"        unsigned_hash::init(st, ed);",
			"    }",
			"",
			"    void set_string(std::string s) {",
			"        unsigned_hash::init(s.begin(), s.end());",
			"    }",
			"",
			"    void init(s_it st, s_it ed) {",
			"        unsigned_hash::s = std::string(st, ed);",
			"        unsigned_hash::size = (int) distance(st, ed);",
			"    }",
			"",
			"    void resize(int i = 0) {",
			"        unsigned_hash::f_hash[i].resize(size, 0);",
			"        unsigned_hash::r_hash[i].resize(size, 0);",
			"        unsigned_hash::expo[i].resize(size + 1, 1);",
			"    }",
			"",
			"    void compute_expo(int i = 0) {",
			"        for (int j = 1; j <= unsigned_hash::size; ++j) {",
			"            expo[i][j] = expo[i][j - 1] * base[i];",
			"        }",
			"    }",
			"",
			"    void compute_single_hash(int i = 0) {",
			"        resize(i);",
			"        compute_expo(i);",
			"        uint64_t fh = 0, rh = 0;",
			"        for (int j = 0; j < unsigned_hash::size; ++j) {",
			"            fh = fh * base[i] + s[j];",
			"            rh = rh * base[i] + s[unsigned_hash::size - j - 1];",
			"            unsigned_hash::f_hash[i][j] = fh;",
			"            unsigned_hash::r_hash[i][unsigned_hash::size - 1 - j] = rh;",
			"        }",
			"    }",
			"",
			"    void compute_double_hash() {",
			"        compute_single_hash(0);",
			"        compute_single_hash(1);",
			"    }",
			"",
			"    uint64_t get_single_f_hash(int l, int r, int i = 0) {",
			"        return f_hash[i][r] - (l > 0 ? f_hash[i][l - 1] * expo[i][r - l + 1] : 0);",
			"    }",
			"",
			"    uint64_t get_double_f_hash(int l, int r) {",
			"        return (unsigned_hash::get_single_f_hash(l, r, 0) << 32) ^ unsigned_hash::get_single_f_hash(l, r, 1);",
			"    }",
			"",
			"    uint64_t get_single_r_hash(int l, int r, int i = 0) {",
			"        return r_hash[i][l] - (r < size - 1 ? r_hash[i][r + 1] * expo[i][r - l + 1] : 0);",
			"    }",
			"",
			"    uint64_t get_double_r_hash(int l, int r) {",
			"        return (unsigned_hash::get_single_r_hash(l, r, 0) << 32) ^ unsigned_hash::get_single_r_hash(l, r, 1);",
			"    }",
			"",
			"    int length() const {",
			"        return unsigned_hash::size;",
			"    }",
			"};",
		],
		"description": "Polynomial Hashing Utility: Unsigned"
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const int N = 1e8;",
			"bitset<N + 1> is_prime;",
			"",
			"void sieve() {",
			"    // false = prime, true = not prime",
			"    is_prime[0] = is_prime[1] = true;",
			"    for (int i = 4; i <= N; i += 2) is_prime[i] = true;",
			"",
			"    for (int64_t i = 3; i * i <= N; i += 2) {",
			"        if (!is_prime[i]) {",
			"            for (int64_t j = i * i; j <= N; j += i + i) is_prime[j] = true;",
			"        }",
			"    }",
			"}",
		],
		"description": ""
	},
	"Bitwise Sieve of Eratosthenes": {
		"prefix": "sieveBitwise",
		"body": [
			"const int MXX = 1e8;",
			"uint32_t isPrime[MXX / 32 + 5];",
			"",
			"// 173th bit = 173 / 32 + 173 % 32",
			"//           = isPrime[173 / 32] [173 % 32]",
			"void sieve() {",
			"    // false = prime, true = not prime",
			"    SET(isPrime[0 / 32], 0 % 32);",
			"    SET(isPrime[0 / 32], 1 % 32);",
			"    for (int i = 4; i <= MXX; i += 2) {",
			"        SET(isPrime[i / 32], i % 32);",
			"    }",
			"    for (ll i = 3; i * i <= MXX; i += 2) {",
			"        if (!isSET(isPrime[i / 32], i % 32)) {",
			"            for (ll j = i * i; j <= MXX; j += i + i) {",
			"                SET(isPrime[j / 32], j % 32);",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": ""
	},
	"Sieve in Linear Time Complexity": {
		"prefix": "sieveN",
		"body": [
			"const int mxx = 1e6;",
			"int spf[mxx + 1];",
			"vector<int> pr;",
			"",
			"void sieve_N() {",
			"    spf[0] = spf[1] = 1;",
			"    for (int i = 2; i <= mxx; ++i) {",
			"        if (!spf[i]) spf[i] = i, pr.push_back(i);",
			"",
			"        int sz = (int) pr.size();",
			"        for (int j = 0; j < sz && pr[j] <= spf[i] && i * pr[j] <= mxx; ++j)",
			"            spf[i * pr[j]] = pr[j];",
			"    }",
			"}"
		],
		"description": ""
	},
	"Sum of Divisors of a number": {
		"prefix": "sod",
		"body": [
			"const int N = 1000001;",
			"int sod[N + 1];",
			"void generate_sod() {",
			"    for (int i = 1; i <= N; ++i) {",
			"        for (int j = i; j <= N; j += i) {",
			"            sod[j] += i;",
			"        }",
			"    }",
			"}"
		],
		"description": ""
	},
	"CP Template": {
		"prefix": "start",
		"body": [
			"// Created by Sarwar on $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR",
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"const int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};",
			"const int dy[] = {0, 0, -1, 1, -1, 1, -1, 1};",
			"",
			"#define ll int64_t",
			"#define u32 unsigned int",
			"#define fastIO ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0)",
			"#define all(x) x.begin(), x.end()",
			"#define mem(x, v) memset(x, v, sizeof x)",
			"#define verdict (ok ? \"YES\" : \"NO\")",
			"#define dbg(x) cout << #x << \" = \" << x << '\\n';",
			"#define read freopen(\"in.txt\", \"r\", stdin)",
			"#define write freopen(\"out.txt\", \"w\", stdout)",
			"#define endl '\\n'",
			"",
			"int main() {",
			"    fastIO;",
			"   ",
			"    $0",
			"",
			"    return 0;",
			"}"
		],
		"description": "CP template"
	},
	"For loop 0 based": {
		"prefix": "for0",
		"body": [
			"for (int ${1:i} = 0; ${1:i} < $2; ++${1:i}) {",
			"    $0",
			"}"
		],
		"description": "For loop"
	},
	"For loop 1 based": {
		"prefix": "for1",
		"body": [
			"for (int ${1|i,j,k|} = 1; ${1|i,j,k|} <= $2; ++${1|i,j,k|}) {",
			"    $0",
			"}"
		],
		"description": "For loop"
	},
	"pair<int, int>": {
		"prefix": "pii",
		"body": [
			"pair<int, int> "
		],
	},
	"tuple<int, int, int>": {
		"prefix": "tiii",
		"body": [
			"tuple<int, int, int> "
		],
	},
	"Counting Sort Algorithm": {
		"prefix": "countsort",
		"body": [
			"void counting_sort(vector<int>& a) {",
			"  int n = (int) a.size();",
			"  int mxe = *max_element(a.begin(), a.end());",
			"  vector<int> b(n), freq(mxe + 1);",
			"",
			"  for (int& i : a) ++freq[i];",
			"  partial_sum(freq.begin(), freq.end(), freq.begin());",
			"",
			"  for (int i = n - 1; i >= 0; --i) {",
			"    b[freq[a[i]] - 1] = a[i];",
			"    --freq[a[i]];",
			"  }",
			"  for (int i = 0; i < n; ++i) {",
			"    a[i] = b[i];",
			"  }",
			"}",
		],
		"description": "Counting Sort Algorithm"
	},
	"Pragma Optimizations": {
		"prefix": "pragmaoptimize",
		"body": [
			"#pragma GCC optimize(\"Ofast,fast-math\")",
			"#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")",
			"#pragma GCC optimization(\"unroll-loops\")",
		],
		"description": "Pragma Optimizations"
	},
	"Sparse Table: Modular Version": {
		"prefix": "sparse_class",
		"body": [
			"template<typename Tp>",
			"struct sparse {",
			"  vector<vector<Tp>> st;",
			"  vector<Tp> lgs;",
			"  int n, lg;",
			"",
			"  explicit sparse(const vector<Tp>& a) {",
			"    sparse::n = (int) a.size();",
			"    sparse::lg = __lg(sparse::n) + 1;",
			"    sparse::lgs.resize(sparse::n + 1);",
			"    sparse::st.resize(n, vector<Tp>(sparse::lg, 0));",
			"    sparse::init(a);",
			"  }",
			"",
			"  void init(const vector<Tp>& a) {",
			"    for (int i = 0; i < n; ++i) st[i][0] = a[i], lgs[i + 1] = __lg(i + 1);",
			"    for (int j = 1; j < lg; ++j) {",
			"      for (int i = 0; i + (1 << j) - 1 < n; ++i) {",
			"        st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);",
			"      }",
			"    }",
			"  }",
			"  Tp query(int L, int R) {",
			"    int lg = lgs[R - L + 1];",
			"    return min(st[L][lg], st[R - (1 << lg) + 1][lg]);",
			"  }",
			"",
			"  Tp query_d(int L, int R) {",
			"    Tp sum = 0;",
			"    while (L <= R) {",
			"      int lg = lgs[R - L + 1];",
			"      sum += st[L][lg];",
			"      L += (1 << lg);",
			"    }",
			"    return sum;",
			"  }",
			"};",
		],
		"description": "Sparse Table: Modular Version"
	},
	
	
	"Sieve upto 10^9": {
		"prefix": "sieve1e9",
		"body": [
			"vector<int> sieve(const int N, const int Q = 17, const int L = 1 << 15) {",
			"  static const int rs[] = {1, 7, 11, 13, 17, 19, 23, 29};",
			"  struct P {",
			"    P(int p) : p(p) {}",
			"    int p, pos[8];",
			"  };",
			"  auto approx_prime_count = [](const int N) -> int {",
			"    return (N > 60184) ? N / (log(N) - 1.1) : max(1., N / (log(N) - 1.11)) + 1;",
			"  };",
			"",
			"  const int v = sqrt(N), vv = sqrt(v);",
			"  vector<bool> isp(v + 1, true);",
			"  for (int i = 2; i <= vv; ++i)",
			"    if (isp[i]) {",
			"      for (int j = i * i; j <= v; j += i) isp[j] = false;",
			"    }",
			"",
			"  const int rsize = approx_prime_count(N + 30);",
			"  vector<int> primes = {2, 3, 5};",
			"  int psize = 3;",
			"  primes.resize(rsize);",
			"",
			"  vector<P> sprimes;",
			"  size_t pbeg = 0;",
			"  int prod = 1;",
			"  for (int p = 7; p <= v; ++p) {",
			"    if (!isp[p]) continue;",
			"    if (p <= Q) prod *= p, ++pbeg, primes[psize++] = p;",
			"    auto pp = P(p);",
			"    for (int t = 0; t < 8; ++t) {",
			"      int j = (p <= Q) ? p : p * p;",
			"      while (j % 30 != rs[t]) j += p << 1;",
			"      pp.pos[t] = j / 30;",
			"    }",
			"    sprimes.push_back(pp);",
			"  }",
			"",
			"  vector<unsigned char> pre(prod, 0xFF);",
			"  for (size_t pi = 0; pi < pbeg; ++pi) {",
			"    auto pp = sprimes[pi];",
			"    const int p = pp.p;",
			"    for (int t = 0; t < 8; ++t) {",
			"      const unsigned char m = ~(1 << t);",
			"      for (int i = pp.pos[t]; i < prod; i += p) pre[i] &= m;",
			"    }",
			"  }",
			"",
			"  const int block_size = (L + prod - 1) / prod * prod;",
			"  vector<unsigned char> block(block_size);",
			"  unsigned char* pblock = block.data();",
			"  const int M = (N + 29) / 30;",
			"",
			"  for (int beg = 0; beg < M; beg += block_size, pblock -= block_size) {",
			"    int end = min(M, beg + block_size);",
			"    for (int i = beg; i < end; i += prod) {",
			"      copy(pre.begin(), pre.end(), pblock + i);",
			"    }",
			"    if (beg == 0) pblock[0] &= 0xFE;",
			"    for (size_t pi = pbeg; pi < sprimes.size(); ++pi) {",
			"      auto& pp = sprimes[pi];",
			"      const int p = pp.p;",
			"      for (int t = 0; t < 8; ++t) {",
			"        int i = pp.pos[t];",
			"        const unsigned char m = ~(1 << t);",
			"        for (; i < end; i += p) pblock[i] &= m;",
			"        pp.pos[t] = i;",
			"      }",
			"    }",
			"    for (int i = beg; i < end; ++i) {",
			"      for (int m = pblock[i]; m > 0; m &= m - 1) {",
			"        primes[psize++] = i * 30 + rs[__builtin_ctz(m)];",
			"      }",
			"    }",
			"  }",
			"  assert(psize <= rsize);",
			"  while (psize > 0 && primes[psize - 1] > N) --psize;",
			"  primes.resize(psize);",
			"  return primes;",
			"}",
		],
		"description": "Sieve upto 10^9"
	},
	
	

	"Merge Sort Algorithm": {
		"prefix": "mergesort",
		"body": [
			"void merge(vector<int> &A, int L, int R) {",
			"    int mid = (L + R) / 2;",
			"    vector<int> merged(R - L + 1);",
			"    int i = L, j = mid + 1, k = 0;",
			"    for (; i <= mid && j <= R;) {",
			"        if (A[i] < A[j]) {",
			"            merged[k++] = A[i];",
			"            ++i;",
			"        } else {",
			"            merged[k++] = A[j];",
			"            ++j;",
			"        }",
			"    }",
			"    while (i <= mid) merged[k++] = A[i], ++i;",
			"    while (j <= R) merged[k++] = A[j], ++j;",
			"    for (auto m: merged) A[L++] = m;",
			"",
			"}",
			"",
			"void merge_sort(vector<int> &A, int L, int R) {",
			"    int size = R - L + 1;",
			"    if (size == 1) {",
			"        return;",
			"    }",
			"    int mid = (L + R) / 2;",
			"    merge_sort(A, L, mid);",
			"    merge_sort(A, mid + 1, R);",
			"    merge(A, L, R);",
			"}",
			"",
			"void merge_sort(vector<int> &A) {",
			"    merge_sort(A, 0, (int) A.size() - 1);",
			"}"
		],
		"description": ""
	},
	"Mod of large numbers represented as strings": {
		"prefix": "strmod",
		"body": [
			"int mod(string s, int m) {",
			"    int rem = 0;",
			"    for (char i : s) {",
			"        int dig = i - '0';",
			"        rem = (rem * 10) + dig;",
			"        rem %= m;",
			"    }",
			"    return rem;",
			"}"
		],
		"description": ""
	},
	"nCr : Iterative Version": {
		"prefix": "ncri",
		"body": [
			"const int N_MAX = 105, R_MAX = 85;",
			"int64_t NCR[N_MAX][R_MAX];",
			"",
			"void genNCR() {",
			"    for (int i = 0; i < N_MAX; ++i) {",
			"        NCR[i][0] = 1;",
			"        if (i < R_MAX) NCR[i][i] = 1;",
			"    }",
			"    for (int i = 1; i < N_MAX; ++i) {",
			"        for (int j = 1; j <= i; ++j) {",
			"            NCR[i][j] = NCR[i - 1][j - 1] + NCR[i - 1][j];",
			"        }",
			"    }",
			"}"
		],
		"description": ""
	},
	"Find N from given sum": {
		"prefix": "findNgivenSum",
		"body": [
			"int get_N(int64_t sum) {",
			"    int N = sqrt(2 * sum);",
			"    return 1LL * N * (N + 1) < 2 * sum ? N + 1 : N;",
			"}"
		],
		"description": ""
	},
	"Extended Euclidean Algorithm": {
		"prefix": "egcd",
		"body": [
			"template <typename T = int>",
			"T egcd(T a, T b, T& x, T& y) {",
			"    x = 1, y = 0;",
			"    T x1 = 0, y1 = 1, a1 = a, b1 = b;",
			"    while (b1 > 0) {",
			"        T q = a1 / b1;",
			"        tie(x, x1) = make_pair(x1, x - q * x1);",
			"        tie(y, y1) = make_pair(y1, y - q * y1);",
			"        tie(a1, b1) = make_pair(b1, a1 - q * b1);",
			"    }",
			"    return a1;",
			"}",
		],
		"description": ""
	},
	"Modular Inverse: Extended Euclidean Algorithm": {
		"prefix": "invmodE",
		"body": [
			"int64_t invModE(int64_t a, int64_t m) {",
			"    // Modular multiplicative inverse using extended euclidean algorithm",
			"    // a and m are coprime",
			"    int64_t x, y, g = egcd(a, m, x, y);",
			"    if (x < 0)",
			"        x = (x + m) % m;",
			"",
			"    return x;",
			"}",
		],
		"description": ""
	},
	"Modular Inverse: Fermat's Little Theorem": {
		"prefix": "invmodF",
		"body": [
			"int64_t invModF(int64_t a, int64_t m) {",
			"    // Modular multiplicative inverse using fermat's little theorem",
			"    // m is a prime number",
			"    return bin_expo(a, m - 2, m);",
			"}",
		],
		"description": ""
	},
	"Test Cases": {
		"prefix": "tc",
		"body": [
			"int t;",
			"cin >> t;",
			"for (int tc = 1; tc <= t; ++tc) {",
			"    $0",
			"",
			"}"
		],
		"description": ""
	},
	"Euler's Totient Function": {
		"prefix": "totient",
		"body": [
			"vector<int> phi;",
			"void totient(int n) {",
			"    phi.resize(n + 1);",
			"    phi[0] = 0, phi[1] = 1;",
			"    for (int i = 2; i <= n; ++i) phi[i] = i;",
			"",
			"    for (int i = 2; i <= n; ++i) {",
			"        if (phi[i] == i)",
			"            for (int j = i; j <= n; j += i) phi[j] -= phi[j] / i;",
			"    }",
			"}"
		],
		"description": ""
	},
	"For iterator loop": {
		"prefix": "foritr",
		"body": [
			"for (auto it = $x.begin(); it != $x.end(); ++it) {",
			"    ",
			"}"
		],
		"description": ""
	},
	"Check if 3 points are collinear": {
		"prefix": "collinear",
		"body": [
			"bool collinear(int x1, int y1, int x2, int y2, int x3, int y3) {",
			"    return (y2 - y1) * (x3 - x2) == (x2 - x1) * (y3 - y2);",
			"}"
		],
		"description": "Slope Method"
	},
	"Polynomial Hashing Utility: Dynamic": {
		"prefix": "phash_antihack",
		"body": [
			"constexpr int PR[] = {2147462393, 2147462419, 2147462587, 2147462633, 2147462747, 2147463167, 2147463203, 2147463569, 2147463727, 2147463863, 2147464211, 2147464549, 2147464751, 2147465153, 2147465563, 2147465599, 2147465743, 2147465953, 2147466457, 2147466463, 2147466521, 2147466721, 2147467009, 2147467057, 2147467067, 2147467261, 2147467379, 2147467463, 2147467669, 2147467747, 2147468003, 2147468317, 2147468591, 2147468651, 2147468779, 2147468801, 2147469017, 2147469041, 2147469173, 2147469229, 2147469593, 2147469881, 2147469983, 2147470027, 2147470081, 2147470177, 2147470673, 2147470823, 2147471057, 2147471327, 2147471581, 2147472137, 2147472161, 2147472689, 2147472697, 2147472863, 2147473151, 2147473369, 2147473733, 2147473891, 2147473963, 2147474279, 2147474921, 2147474929, 2147475107, 2147475221, 2147475347, 2147475397, 2147475971, 2147476739, 2147476769, 2147476789, 2147476927, 2147477063, 2147477107, 2147477249, 2147477807, 2147477933, 2147478017, 2147478521};",
			"array<int, 2> base{47, 59}, mod{int(1E9 + 7), int(1E9 + 9)};",
			"",
			"void init() {",
			"  constexpr int nprimes = (sizeof(PR) / sizeof(PR[0])) / 4;",
			"",
			"  auto rand = [&]() -> int {",
			"    uint64_t seed = chrono::system_clock::now().time_since_epoch().count();",
			"    mt19937 mt(seed);",
			"    uniform_int_distribution<int> num(0, nprimes - 1);",
			"    return num(mt);",
			"  };",
			"",
			"  base[0] = PR[rand()];",
			"  mod[0] = PR[rand() + nprimes];",
			"  base[1] = PR[rand() + 2 * nprimes];",
			"  mod[1] = PR[rand() + 3 * nprimes];",
			"}",
			"struct polynomial_hash {",
			"  std::array<int, 2> base = ::base;",
			"  std::array<int, 2> mod = ::mod;",
			"  std::array<std::vector<int>, 2> f_hash, r_hash;",
			"  std::array<std::vector<int>, 2> expo;",
			"  std::string s;",
			"  int size = 0;",
			"  using s_it = std::string::iterator;",
			"",
			"  polynomial_hash() = default;",
			"",
			"  polynomial_hash(s_it st, s_it ed) {",
			"    polynomial_hash::init(st, ed);",
			"  }",
			"  explicit polynomial_hash(std::string s) {",
			"    polynomial_hash::init(s.begin(), s.end());",
			"  }",
			"  polynomial_hash(s_it st, s_it ed, std::initializer_list<int> base, std::initializer_list<int> mod) {",
			"    for (const int& i : {0, 1}) {",
			"      polynomial_hash::base[i] = *(base.begin() + i);",
			"      polynomial_hash::mod[i] = *(mod.begin() + i);",
			"    }",
			"    polynomial_hash::init(st, ed);",
			"  }",
			"",
			"  void set_string(std::string s) {",
			"    polynomial_hash::init(s.begin(), s.end());",
			"  }",
			"",
			"  void init(s_it st, s_it ed) {",
			"    polynomial_hash::s = std::string(st, ed);",
			"    polynomial_hash::size = (int) distance(st, ed);",
			"  }",
			"",
			"  void resize(int i = 0) {",
			"    polynomial_hash::f_hash[i].resize(size, 0);",
			"    polynomial_hash::r_hash[i].resize(size, 0);",
			"    polynomial_hash::expo[i].resize(size + 1, 1);",
			"  }",
			"",
			"  void compute_expo(int i = 0) {",
			"    for (int j = 1; j <= polynomial_hash::size; ++j) {",
			"      expo[i][j] = int((1LL * expo[i][j - 1] * base[i]) % mod[i]);",
			"    }",
			"  }",
			"  void compute_single_hash(int i = 0) {",
			"    resize(i);",
			"    compute_expo(i);",
			"    int fh = 0, rh = 0;",
			"    for (int j = 0; j < polynomial_hash::size; ++j) {",
			"      fh = int((1LL * fh * base[i] + s[j]) % mod[i]);",
			"      rh = int((1LL * rh * base[i] + s[polynomial_hash::size - j - 1]) % mod[i]);",
			"      polynomial_hash::f_hash[i][j] = fh;",
			"      polynomial_hash::r_hash[i][polynomial_hash::size - 1 - j] = rh;",
			"    }",
			"  }",
			"",
			"  void compute_double_hash() {",
			"    compute_single_hash(0);",
			"    compute_single_hash(1);",
			"  }",
			"",
			"  uint64_t get_single_f_hash(int l, int r, int i = 0) {",
			"    if (l > r) return 0;",
			"    int h = 0;",
			"    h = int((f_hash[i][r] - (l > 0 ? 1LL * f_hash[i][l - 1] * expo[i][r - l + 1] : 0)) % mod[i]);",
			"    return h < 0 ? h += mod[i] : h;",
			"  }",
			"",
			"  uint64_t get_double_f_hash(int l, int r) {",
			"    return (polynomial_hash::get_single_f_hash(l, r, 0) << 32) ^ polynomial_hash::get_single_f_hash(l, r, 1);",
			"  }",
			"",
			"  uint64_t get_single_r_hash(int l, int r, int i = 0) {",
			"    int h = 0;",
			"    h = int((r_hash[i][l] - (r < size - 1 ? 1LL * r_hash[i][r + 1] * expo[i][r - l + 1] : 0)) % mod[i]);",
			"    return h < 0 ? h += mod[i] : h;",
			"  }",
			"",
			"  uint64_t get_double_r_hash(int l, int r) {",
			"    return (polynomial_hash::get_single_r_hash(l, r, 0) << 32) ^ polynomial_hash::get_single_r_hash(l, r, 1);",
			"  }",
			"",
			"  int length() const {",
			"    return polynomial_hash::size;",
			"  }",
			"};",
			"",
		],
		"description": "Polynomial Hashing Utility: Dynamic"
	},
	"CP Template: Minimal Version": {
		"prefix": "cptemp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"",
			"void run_case(int tc) {",
			"  $0",
			"}",
			"",
			"int main() {",
			"  ios_base::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"",
			"  int t = 1;",
			"  $1cin >> t;",
			"  for (int tc = 1; tc <= t; ++tc) {",
			"    run_case(tc);",
			"  }",
			"",
			"",
			"  return 0;",
			"}",
		],
		"description": ""
	},
	"Namespace: int128 utility": {
		"prefix": "int128u",
		"body": [
			"namespace int128_utility {",
			"    std::istream &operator>>(std::istream &in, __int128 &n) {",
			"        std::string s;",
			"        in >> s;",
			"        bool neg = !s.empty() && s.front() == '-';",
			"        n = 0;",
			"        for (size_t i = 0 + neg; i < s.length(); ++i) {",
			"            n = n * 10 + (s[i] - '0');",
			"        }",
			"        if (neg) n *= -1;",
			"        return in;",
			"    }",
			"",
			"    std::ostream &operator<<(std::ostream &out, __int128 n) {",
			"        bool neg = n < 0;",
			"        std::string s;",
			"        do {",
			"            s += to_string(abs(int(n % 10)));",
			"            n /= 10;",
			"        } while (neg ? n < 0 : n > 0);",
			"        if (neg) s += '-';",
			"        std::reverse(s.begin(), s.end());",
			"        out << s;",
			"        return out;",
			"    }",
			"}",
			"using namespace int128_utility;"
		],
		"description": ""
	},
	"Namespace: Geometry": {
		"prefix": "geometry",
		"body": [
			"namespace geometry {",
			"",
			"    template<typename type>",
			"    struct Point {",
			"        type x, y;",
			"",
			"        Point(type x, type y) {",
			"            Point::x = x;",
			"            Point::y = y;",
			"        }",
			"",
			"        Point() { x = 0, y = 0; }",
			"    };",
			"",
			"    template<typename T>",
			"    double slope(Point<T> a, Point<T> b) {",
			"        return 1.0 * (b.y - a.y) / (b.x - a.x);",
			"    }",
			"",
			"    template<typename T>",
			"    double dist(Point<T> a, Point<T> b) {",
			"        return sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));",
			"    }",
			"",
			"    template<typename T>",
			"    bool collinear(Point<T> a, Point<T> b, Point<T> c) {",
			"        return (b.y - a.y) * (c.x - b.x) == (b.x - a.x) * (c.y - b.y);",
			"    }",
			"",
			"    template<typename T>",
			"    T tri_area_doubled(Point<T> a, Point<T> b, Point<T> c) {",
			"        return abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));",
			"    }",
			"",
			"    template<typename T>",
			"    T rect_area(Point<T> bottom_left, Point<T> top_right) {",
			"        return (top_right.y - bottom_left.y) * (top_right.x - bottom_left.x);",
			"    }",
			"",
			"    template<typename type>",
			"    struct Rectangle {",
			"        // Bottom Left, Top Right",
			"        Point<type> bl, tr;",
			"",
			"        Rectangle(Point<type> bl, Point<type> tr) {",
			"            Rectangle::bl = bl;",
			"            Rectangle::tr = tr;",
			"        }",
			"",
			"        type area() const {",
			"            return (tr.y - bl.y) * (tr.x - bl.x);",
			"        }",
			"    };",
			"",
			"    template<typename T>",
			"    pair<T, T> intersection(vector<Rectangle<T>> rects) {",
			"        // returns <x_intersection_length, y_intersection_length>",
			"        T mn_tr_x = numeric_limits<T>::max(), mx_bl_x = numeric_limits<T>::min();",
			"        for (Rectangle i: rects) {",
			"            mn_tr_x = min(mn_tr_x, i.tr.x);",
			"            mx_bl_x = max(mx_bl_x, i.bl.x);",
			"        }",
			"        T x = max(static_cast<T>(0), mn_tr_x - mx_bl_x);",
			"",
			"        T mn_tr_y = numeric_limits<T>::max(), mx_bl_y = numeric_limits<T>::min();",
			"        for (Rectangle i: rects) {",
			"            mn_tr_y = min(mn_tr_y, i.tr.y);",
			"            mx_bl_y = max(mx_bl_y, i.bl.y);",
			"        }",
			"        T y = max(static_cast<T>(0), mn_tr_y - mx_bl_y);",
			"",
			"        return make_pair(x, y);",
			"    }",
			"",
			"    template<typename T>",
			"    T intersect_area(vector<Rectangle<T>> rects) {",
			"        pair<T, T> sides = intersection(std::move(rects));",
			"        return sides.first * sides.second;",
			"    }",
			"",
			"    template<typename T>",
			"    istream &operator>>(istream &in, Rectangle<T> &r) {",
			"        in >> r.bl.x >> r.bl.y >> r.tr.x >> r.tr.y;",
			"        return in;",
			"    }",
			"",
			"    template<typename T>",
			"    istream &operator>>(istream &in, Point<T> &p) {",
			"        in >> p.x >> p.y;",
			"        return in;",
			"    }",
			"",
			"    template<typename T>",
			"    ostream &operator<<(ostream &out, Point<T> &p) {",
			"        out << \"(\" << p.x << \",\" << p.y << \")\";",
			"        return out;",
			"    }",
			"}",
			"using namespace geometry;"
		],
		"description": ""
	},
	"Namespace: Mathematical Progression": {
		"prefix": "progression",
		"body": [
			"namespace mathematical_progression {",
			"    template<typename type>",
			"    type arithmetic_nth_term(type a, type n, type d) {",
			"        return a + (n - 1) * d;",
			"    }",
			"",
			"    template<typename type>",
			"    type arithmetic_sum(type a, type n, type d) {",
			"        return n * (2 * a + (n - 1) * d) / 2;",
			"    }",
			"",
			"",
			"    template<typename type>",
			"    type geometric_nth_term(type a, type n, type r) {",
			"        return a * pow(r, n - 1);",
			"    }",
			"",
			"    template<typename type>",
			"    type geometric_sum(type a, type n, type r) {",
			"        if (r == 1) return n * a;",
			"        if (r < 1) return a * (1 - pow(r, n)) / (1 - r);",
			"        else return a * (pow(r, n) - 1) / (r - 1);",
			"    }",
			"",
			"    template<typename type>",
			"    type infinite_geometric_sum(type a, type r) {",
			"        assert(r < 1);",
			"        return a / (1 - r);",
			"    }",
			"}",
			"",
			"using namespace mathematical_progression;"
		],
		"description": ""
	},
	"Namespace: Base Conversion": {
		"prefix": "conversion",
		"body": [
			"namespace base_conversion {",
			"    int64_t to_decimal(string N, int base) {",
			"        return stoll(N, nullptr, base);",
			"    }",
			"",
			"    string from_decimal(int64_t N, int base) {",
			"        char *buffer = new char[sizeof(N) * 8 + 1];",
			"        _i64toa(N, buffer, base);",
			"        return string(buffer);",
			"    }",
			"}",
			"using namespace base_conversion;"
		],
		"description": ""
	},
	"Ceiling Division": {
		"prefix": "ceildiv",
		"body": [
			"int64_t ceil_div(int64_t n, int64_t m) {",
			"    return n / m + (n % m != 0);",
			"}"
		],
		"description": ""
	},
	"Make a vector unique": {
		"prefix": "make_unique",
		"body": [
			"template<typename T>",
			"void make_unique(vector<T> &v) {",
			"    std::sort(v.begin(), v.end());",
			"    v.erase(std::unique(v.begin(), v.end()), v.end());",
			"}"
		],
		"description": ""
	},
	"Chinese Remainder Theorem": {
		"prefix": "crt",
		"body": [
			"template <typename T = int64_t>",
			"T egcd(T a, T b, T& x, T& y) {",
			"    x = 1, y = 0;",
			"    T x1 = 0, y1 = 1, a1 = a, b1 = b;",
			"    while (b1 > 0) {",
			"        T q = a1 / b1;",
			"        tie(x, x1) = make_pair(x1, x - q * x1);",
			"        tie(y, y1) = make_pair(y1, y - q * y1);",
			"        tie(a1, b1) = make_pair(b1, a1 - q * b1);",
			"    }",
			"    return a1;",
			"}",
			"template <typename T = int64_t>",
			"T invModE(T a, T m) {",
			"    // Modular multiplicative inverse using extended euclidean algorithm",
			"    // a and m are coprime",
			"    T x, y, g = egcd(a, m, x, y);",
			"    if (x < 0)",
			"        x = (x + m) % m;",
			"",
			"    return x;",
			"}",
			"",
			"int64_t crt(vector<int> nums, vector<int> rems) {",
			"",
			"    __int128_t prod = 1;",
			"",
			"    int n = nums.size();",
			"",
			"    for (int i = 0; i < n; ++i)",
			"        prod *= nums[i];",
			"",
			"    int res = 0;",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        __int128_t pp = prod / nums[i];",
			"        res += rems[i] * invModE<__int128_t>(pp, nums[i]) * pp;",
			"    }",
			"",
			"    return res % prod;",
			"}",
		],
		"description": ""
	},
	"CP Template with GNU PBDS": {
		"prefix": "pbds",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"#ifdef LOCAL",
			"#include \"debug.hh\"",
			"#else",
			"#define dbg(x) \"\"",
			"#endif",
			"",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"",
			"template<typename T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template<typename A, typename B>",
			"using ordered_map = tree<A, B, less<A>, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"int main() {",
			"#ifdef LOCAL",
			"    freopen(\"in.txt\", \"r\", stdin);",
			"    freopen(\"out.txt\", \"w\", stdout);",
			"#endif",
			"",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    $0",
			"",
			"",
			"    return 0;",
			"}",
		],
		"description": ""
	},
	"Big Integer": {
		"prefix": "bigint",
		"body": [
			"static const int BASE = 1000000000;",
			"static const int UPPER_BOUND = 999999999;",
			"static const int DIGIT_COUNT = 9;",
			"static const int powersOfTen[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};",
			"",
			"inline static div_t my_div(int num, int denom) {",
			"    div_t result;",
			"    result.quot = num / denom;",
			"    result.rem = num - denom * result.quot;",
			"    return result;",
			"}",
			"",
			"inline static lldiv_t my_lldiv(int64_t num, int64_t denom) {",
			"    lldiv_t result;",
			"    result.quot = num / denom;",
			"    result.rem = num - denom * result.quot;",
			"    return result;",
			"}",
			"",
			"class big_int {",
			"    friend std::ostream& operator<<(std::ostream& s, const big_int& n);",
			"    friend std::istream& operator>>(std::istream& s, big_int& val);",
			"",
			"public:",
			"    /* constructors */",
			"    big_int();",
			"    big_int(const char* c);",
			"    big_int(const std::string& s);",
			"    big_int(int l);",
			"    big_int(int64_t l);",
			"    big_int(uint32_t l);",
			"    big_int(uint64_t l);",
			"    big_int(const big_int& l);",
			"",
			"    /* assignment operators */",
			"    const big_int& operator=(const char* c);",
			"    const big_int& operator=(const std::string& s);",
			"    const big_int& operator=(int l);",
			"    const big_int& operator=(int64_t l);",
			"    const big_int& operator=(uint32_t l);",
			"    const big_int& operator=(uint64_t l);",
			"    const big_int& operator=(const big_int& l);",
			"",
			"    /* unary increment/decrement operators */",
			"    const big_int& operator++();",
			"    const big_int& operator--();",
			"    big_int operator++(int);",
			"    big_int operator--(int);",
			"",
			"    /* operational assignments */",
			"    const big_int& operator+=(const big_int& rhs);",
			"    const big_int& operator-=(const big_int& rhs);",
			"    const big_int& operator*=(const big_int& rhs);",
			"    const big_int& operator/=(const big_int& rhs);",
			"    const big_int& operator%=(const big_int& rhs);",
			"    const big_int& operator*=(int rhs);",
			"",
			"    /* operations */",
			"    big_int operator-() const;",
			"    big_int operator+(const big_int& rhs) const;",
			"    big_int operator-(const big_int& rhs) const;",
			"    big_int operator*(const big_int& rhs) const;",
			"    big_int operator/(const big_int& rhs) const;",
			"    big_int operator%(const big_int& rhs) const;",
			"    big_int operator*(int rhs) const;",
			"",
			"    /* relational operations */",
			"    bool operator==(const big_int& rhs) const;",
			"    bool operator!=(const big_int& rhs) const;",
			"    bool operator<(const big_int& rhs) const;",
			"    bool operator<=(const big_int& rhs) const;",
			"    bool operator>(const big_int& rhs) const;",
			"    bool operator>=(const big_int& rhs) const;",
			"",
			"    /* integer square root */",
			"    big_int int_sqrt() const;",
			"",
			"    /* digit operations */",
			"    char digit_at(size_t i) const;",
			"    size_t no_of_digits() const;",
			"",
			"    /* size in bytes */",
			"    size_t size() const;",
			"",
			"    /* string conversion */",
			"    std::string to_string() const;",
			"",
			"    /* conversion to primitive types */",
			"    int to_int() const;",
			"    int64_t to_llong() const;",
			"    uint32_t to_uint() const;",
			"    uint64_t to_ullong() const;",
			"",
			"private:",
			"    static int d_i_n_r(const big_int& R, const big_int& D);",
			"    static void multiply_by_digit(int factor, std::vector<int>& val);",
			"",
			"    void correct(bool check_leading_zeros = false, bool has_valid_sign = false);",
			"    void from_string(const std::string& s);",
			"    void optimize_sqrt_search_bounds(big_int& lo, big_int& hi) const;",
			"    void truncate_to_base();",
			"    bool equalize_signs();",
			"    void remove_leading_zeros();",
			"",
			"    std::vector<int> val;",
			"    bool pos;",
			"};",
			"",
			"inline big_int::big_int() : pos(true) {",
			"    val.push_back((int) 0);",
			"}",
			"",
			"inline big_int::big_int(const char* c) {",
			"    from_string(c);",
			"}",
			"",
			"inline big_int::big_int(const std::string& s) {",
			"    from_string(s);",
			"}",
			"",
			"inline big_int::big_int(int l) : pos(l >= 0) {",
			"    bool subtract_one = false;",
			"    if (l == INT_MIN) {",
			"        subtract_one = true;",
			"        ++l;",
			"    }",
			"    if (!pos) l = -l;",
			"    do {",
			"        div_t dt = my_div(l, BASE);",
			"        val.push_back((int) dt.rem);",
			"        l = dt.quot;",
			"    } while (l > 0);",
			"",
			"    if (subtract_one) --*this;",
			"}",
			"",
			"",
			"inline big_int::big_int(int64_t l) : pos(l >= 0) {",
			"    bool subtract_one = false;",
			"    if (l == INT64_MIN) {",
			"        subtract_one = true;",
			"        ++l;",
			"    }",
			"    if (!pos) l = -l;",
			"",
			"    do {",
			"        lldiv_t dt = my_lldiv(l, BASE);",
			"        val.push_back((int) dt.rem);",
			"        l = dt.quot;",
			"    } while (l > 0);",
			"",
			"    if (subtract_one) --*this;",
			"}",
			"",
			"inline big_int::big_int(uint32_t l) : pos(true) {",
			"    do {",
			"        val.push_back((int) (l % BASE));",
			"        l = l / BASE;",
			"    } while (l > 0);",
			"}",
			"",
			"inline big_int::big_int(uint64_t l) : pos(true) {",
			"    do {",
			"        val.push_back((int) (l % BASE));",
			"        l = l / BASE;",
			"    } while (l > 0);",
			"}",
			"",
			"inline big_int::big_int(const big_int& l) : pos(l.pos), val(l.val) {",
			"}",
			"",
			"inline const big_int& big_int::operator=(const char* c) {",
			"    from_string(c);",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator=(const std::string& s) {",
			"    from_string(s);",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator=(int l) {",
			"    bool subtract_one = false;",
			"    if (l == INT_MIN) {",
			"        subtract_one = true;",
			"        ++l;",
			"    }",
			"    pos = l >= 0;",
			"    val.clear();",
			"    if (!pos) {",
			"        l = -l;",
			"    }",
			"    do {",
			"        div_t dt = my_div(l, BASE);",
			"        val.push_back((int) dt.rem);",
			"        l = dt.quot;",
			"    } while (l > 0);",
			"    return subtract_one ? --*this : *this;",
			"}",
			"",
			"inline const big_int& big_int::operator=(int64_t l) {",
			"    bool subtract_one = false;",
			"    if (l == INT64_MIN) {",
			"        subtract_one = true;",
			"        ++l;",
			"    }",
			"    pos = l >= 0;",
			"    val.clear();",
			"    if (!pos) {",
			"        l = -l;",
			"    }",
			"    do {",
			"        lldiv_t dt = my_lldiv(l, BASE);",
			"        val.push_back((int) dt.rem);",
			"        l = dt.quot;",
			"    } while (l > 0);",
			"    return subtract_one ? --*this : *this;",
			"}",
			"",
			"inline const big_int& big_int::operator=(uint32_t l) {",
			"    pos = true;",
			"    val.clear();",
			"    do {",
			"        val.push_back((int) (l % BASE));",
			"        l = l / BASE;",
			"    } while (l > 0);",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator=(uint64_t l) {",
			"    pos = true;",
			"    val.clear();",
			"    do {",
			"        val.push_back((int) (l % BASE));",
			"        l = l / BASE;",
			"    } while (l > 0);",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator=(const big_int& l) {",
			"    pos = l.pos;",
			"    val = l.val;",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator++() {",
			"    val[0] += (pos ? 1 : -1);",
			"    this->correct(false, true);",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator--() {",
			"    val[0] -= (pos ? 1 : -1);",
			"    this->correct(false, true);",
			"    return *this;",
			"}",
			"",
			"inline big_int big_int::operator++(int) {",
			"    big_int result = *this;",
			"    val[0] += (pos ? 1 : -1);",
			"    this->correct(false, true);",
			"    return result;",
			"}",
			"",
			"inline big_int big_int::operator--(int) {",
			"    big_int result = *this;",
			"    val[0] -= (pos ? 1 : -1);",
			"    this->correct(false, true);",
			"    return result;",
			"}",
			"",
			"inline const big_int& big_int::operator+=(const big_int& rhs) {",
			"    if (rhs.val.size() > val.size()) {",
			"        val.resize(rhs.val.size(), 0);",
			"    }",
			"    for (size_t i = 0; i < val.size(); ++i) {",
			"        val[i] = (pos ? val[i] : -val[i]) + (i < rhs.val.size() ? (rhs.pos ? rhs.val[i] : -rhs.val[i]) : 0);",
			"    }",
			"    correct();",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator-=(const big_int& rhs) {",
			"    if (rhs.val.size() > val.size()) {",
			"        val.resize(rhs.val.size(), 0);",
			"    }",
			"    for (size_t i = 0; i < val.size(); ++i) {",
			"        val[i] = (pos ? val[i] : -val[i]) - (i < rhs.val.size() ? (rhs.pos ? rhs.val[i] : -rhs.val[i]) : 0);",
			"    }",
			"    correct();",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator*=(const big_int& rhs) {",
			"    *this = *this * rhs;",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator/=(const big_int& rhs) {",
			"    if (rhs == 0) {",
			"        std::cerr << \"Division by zero!\" << std::endl;",
			"        return *this;",
			"    }",
			"    big_int R, D = (rhs.pos ? rhs : -rhs), N = (pos ? *this : -*this);",
			"    bool old_pos = pos;",
			"    std::fill(val.begin(), val.end(), 0);",
			"    for (int i = (int) N.val.size() - 1; i >= 0; --i) {",
			"        R.val.insert(R.val.begin(), N.val[i]);",
			"        R.correct(true);",
			"        int cnt = d_i_n_r(R, D);",
			"        R -= D * cnt;",
			"        val[i] += cnt;",
			"    }",
			"    correct();",
			"    pos = (val.size() == 1 && val[0] == 0) ? true : (old_pos == rhs.pos);",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator%=(const big_int& rhs) {",
			"    *this = *this % rhs;",
			"    return *this;",
			"}",
			"",
			"inline const big_int& big_int::operator*=(int rhs) {",
			"    int factor = rhs < 0 ? -rhs : rhs;",
			"    bool old_pos = pos;",
			"    multiply_by_digit(factor, val);",
			"    correct();",
			"    pos = (val.size() == 1 && val[0] == 0) ? true : (old_pos == (rhs >= 0));",
			"    return *this;",
			"}",
			"",
			"inline big_int big_int::operator-() const {",
			"    big_int result = *this;",
			"    result.pos = !pos;",
			"    return result;",
			"}",
			"",
			"inline big_int big_int::operator+(const big_int& rhs) const {",
			"    big_int result;",
			"    result.val.resize(val.size() > rhs.val.size() ? val.size() : rhs.val.size(), 0);",
			"    for (size_t i = 0; i < val.size() || i < rhs.val.size(); ++i) {",
			"        result.val[i] = (i < val.size() ? (pos ? val[i] : -val[i]) : 0) + (i < rhs.val.size() ? (rhs.pos ? rhs.val[i] : -rhs.val[i]) : 0);",
			"    }",
			"    result.correct();",
			"    return result;",
			"}",
			"",
			"inline big_int big_int::operator-(const big_int& rhs) const {",
			"    big_int result;",
			"    result.val.resize(val.size() > rhs.val.size() ? val.size() : rhs.val.size(), 0);",
			"    for (size_t i = 0; i < val.size() || i < rhs.val.size(); ++i) {",
			"        result.val[i] = (i < val.size() ? (pos ? val[i] : -val[i]) : 0) - (i < rhs.val.size() ? (rhs.pos ? rhs.val[i] : -rhs.val[i]) : 0);",
			"    }",
			"    result.correct();",
			"    return result;",
			"}",
			"",
			"inline big_int big_int::operator*(const big_int& rhs) const {",
			"    big_int result;",
			"    result.val.resize(val.size() + rhs.val.size(), 0);",
			"    int64_t carry = 0;",
			"    size_t digit = 0;",
			"    for (;; ++digit) {",
			"        lldiv_t dt = my_lldiv(carry, BASE);",
			"        carry = dt.quot;",
			"        result.val[digit] = (int) dt.rem;",
			"",
			"        bool found = false;",
			"        for (size_t i = digit < rhs.val.size() ? 0 : digit - rhs.val.size() + 1; i < val.size() && i <= digit; ++i) {",
			"            int64_t pval = result.val[digit] + val[i] * (int64_t) rhs.val[digit - i];",
			"            if (pval >= BASE || pval <= -BASE) {",
			"                lldiv_t dt = my_lldiv(pval, BASE);",
			"                carry += dt.quot;",
			"                pval = dt.rem;",
			"            }",
			"            result.val[digit] = (int) pval;",
			"            found = true;",
			"        }",
			"        if (!found) {",
			"            break;",
			"        }",
			"    }",
			"    for (; carry > 0; ++digit) {",
			"        lldiv_t dt = my_lldiv(carry, BASE);",
			"        result.val[digit] = (int) dt.rem;",
			"        carry = dt.quot;",
			"    }",
			"    result.correct();",
			"    result.pos = (result.val.size() == 1 && result.val[0] == 0) ? true : (pos == rhs.pos);",
			"    return result;",
			"}",
			"",
			"inline big_int big_int::operator/(const big_int& rhs) const {",
			"    if (rhs == 0) {",
			"        std::cerr << \"Division by zero!\" << std::endl;",
			"        return 0;",
			"    }",
			"    big_int Q, R, D = (rhs.pos ? rhs : -rhs), N = (pos ? *this : -*this);",
			"    Q.val.resize(N.val.size(), 0);",
			"    for (int i = (int) N.val.size() - 1; i >= 0; --i) {",
			"        R.val.insert(R.val.begin(), N.val[i]);",
			"        R.correct(true);",
			"        int cnt = d_i_n_r(R, D);",
			"        R -= D * cnt;",
			"        Q.val[i] += cnt;",
			"    }",
			"    Q.correct();",
			"    Q.pos = (Q.val.size() == 1 && Q.val[0] == 0) ? true : (pos == rhs.pos);",
			"    return Q;",
			"}",
			"",
			"inline big_int big_int::operator%(const big_int& rhs) const {",
			"    if (rhs == 0) {",
			"        std::cerr << \"Division by zero!\" << std::endl;",
			"        return 0;",
			"    }",
			"    big_int R, D = (rhs.pos ? rhs : -rhs), N = (pos ? *this : -*this);",
			"    for (int i = (int) N.val.size() - 1; i >= 0; --i) {",
			"        R.val.insert(R.val.begin(), N.val[i]);",
			"        R.correct(true);",
			"        R -= D * d_i_n_r(R, D);",
			"    }",
			"    R.correct();",
			"    R.pos = (R.val.size() == 1 && R.val[0] == 0) ? true : pos;",
			"    return R;",
			"}",
			"",
			"inline big_int big_int::operator*(int rhs) const {",
			"    big_int result = *this;",
			"    int factor = rhs < 0 ? -rhs : rhs;",
			"    multiply_by_digit(factor, result.val);",
			"    result.correct();",
			"    result.pos = (result.val.size() == 1 && result.val[0] == 0) ? true : (pos == (rhs >= 0));",
			"    return result;",
			"}",
			"",
			"inline bool big_int::operator==(const big_int& rhs) const {",
			"    if (pos != rhs.pos || val.size() != rhs.val.size()) {",
			"        return false;",
			"    }",
			"    for (int i = (int) val.size() - 1; i >= 0; --i) {",
			"        if (val[i] != rhs.val[i]) {",
			"            return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"inline bool big_int::operator!=(const big_int& rhs) const {",
			"    return !(*this == rhs);",
			"}",
			"",
			"inline bool big_int::operator<(const big_int& rhs) const {",
			"    if (pos && !rhs.pos) {",
			"        return false;",
			"    }",
			"    if (!pos && rhs.pos) {",
			"        return true;",
			"    }",
			"    if (val.size() > rhs.val.size()) {",
			"        return pos ? false : true;",
			"    }",
			"    if (val.size() < rhs.val.size()) {",
			"        return pos ? true : false;",
			"    }",
			"    for (int i = (int) val.size() - 1; i >= 0; --i) {",
			"        if (val[i] < rhs.val[i]) {",
			"            return pos ? true : false;",
			"        }",
			"        if (val[i] > rhs.val[i]) {",
			"            return pos ? false : true;",
			"        }",
			"    }",
			"    return false;",
			"}",
			"",
			"inline bool big_int::operator<=(const big_int& rhs) const {",
			"    return (*this < rhs) || (*this == rhs);",
			"}",
			"",
			"inline bool big_int::operator>(const big_int& rhs) const {",
			"    return !(*this <= rhs);",
			"}",
			"",
			"inline bool big_int::operator>=(const big_int& rhs) const {",
			"    return !(*this > rhs);",
			"}",
			"",
			"inline void big_int::optimize_sqrt_search_bounds(big_int& lo, big_int& hi) const {",
			"    big_int hdn = 1;",
			"    for (int i = (int) this->no_of_digits() / 2; i >= 2; --i) {",
			"        hdn *= 10;",
			"    }",
			"    if (lo < hdn) {",
			"        lo = hdn;",
			"    }",
			"    hdn *= 100;",
			"    if (hi > hdn) {",
			"        hi = hdn;",
			"    }",
			"}",
			"",
			"inline big_int big_int::int_sqrt() const {",
			"    if (*this <= 0) {",
			"        std::cerr << \"int_sqrt called for non-positive integer: \" << *this << std::endl;",
			"        return 0;",
			"    }",
			"    big_int hi = *this / 2 + 1, lo = 0, mid, mid2;",
			"    optimize_sqrt_search_bounds(lo, hi);",
			"    do {",
			"        mid = (hi + lo) / 2;",
			"        mid2 = mid * mid;",
			"        if (mid2 == *this) {",
			"            lo = mid;",
			"            break;",
			"        } else if (mid2 < *this) {",
			"            lo = mid;",
			"        } else {",
			"            hi = mid;",
			"        }",
			"    } while (lo < hi - 1 && mid2 != *this);",
			"    return lo;",
			"}",
			"",
			"inline char big_int::digit_at(size_t i) const {",
			"    if (no_of_digits() <= i) {",
			"        std::cerr << \"Invalid digit index: \" << i << std::endl;",
			"        return -1;",
			"    }",
			"    return (val[i / DIGIT_COUNT] / powersOfTen[i % DIGIT_COUNT]) % 10;",
			"}",
			"",
			"inline size_t big_int::no_of_digits() const {",
			"    return (val.size() - 1) * DIGIT_COUNT +",
			"           (val.back() > 99999999 ? 9 : (val.back() > 9999999 ? 8 : (val.back() > 999999 ? 7 : (val.back() > 99999 ? 6 : (val.back() > 9999 ? 5 : (val.back() > 999 ? 4 : (val.back() > 99 ? 3 : (val.back() > 9 ? 2 : 1))))))));",
			"}",
			"",
			"inline std::string big_int::to_string() const {",
			"    std::ostringstream oss;",
			"    oss << *this;",
			"    return oss.str();",
			"}",
			"",
			"inline size_t big_int::size() const {",
			"    return val.size() * sizeof(int) + sizeof(bool);",
			"}",
			"",
			"inline int big_int::to_int() const {",
			"    if (*this > INT_MAX || *this < INT_MIN) {",
			"        std::cerr << \"Out of INT bounds: \" << *this << std::endl;",
			"    }",
			"    int result = 0;",
			"    for (int i = (int) val.size() - 1; i >= 0; --i) {",
			"        result = result * BASE + val[i];",
			"    }",
			"    return pos ? result : -result;",
			"}",
			"",
			"inline int64_t big_int::to_llong() const {",
			"    if (*this > INT64_MAX || *this < INT64_MIN) {",
			"        std::cerr << \"Out of LLONG bounds: \" << *this << std::endl;",
			"    }",
			"    int64_t result = 0;",
			"    for (int i = (int) val.size() - 1; i >= 0; --i) {",
			"        result = result * BASE + val[i];",
			"    }",
			"    return pos ? result : -result;",
			"}",
			"",
			"inline uint32_t big_int::to_uint() const {",
			"    if (!pos || *this > UINT_MAX) {",
			"        std::cerr << \"Out of UINT bounds: \" << *this << std::endl;",
			"    }",
			"    uint32_t result = 0;",
			"    for (int i = (int) val.size() - 1; i >= 0; --i) {",
			"        result = result * BASE + val[i];",
			"    }",
			"    return result;",
			"}",
			"",
			"inline uint64_t big_int::to_ullong() const {",
			"    if (!pos || *this > UINT64_MAX) {",
			"        std::cerr << \"Out of ULLONG bounds: \" << *this << std::endl;",
			"    }",
			"    uint64_t result = 0;",
			"    for (int i = (int) val.size() - 1; i >= 0; --i) {",
			"        result = result * BASE + val[i];",
			"    }",
			"    return result;",
			"}",
			"",
			"inline void big_int::truncate_to_base() {",
			"    for (size_t i = 0; i < val.size(); ++i) {",
			"        if (val[i] >= BASE || val[i] <= -BASE) {",
			"            div_t dt = my_div(val[i], BASE);",
			"            val[i] = dt.rem;",
			"            if (i + 1 >= val.size()) {",
			"                val.push_back(dt.quot);",
			"            } else {",
			"                val[i + 1] += dt.quot;",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"inline bool big_int::equalize_signs() {",
			"    bool isPositive = true;",
			"    int i = (int) ((val.size())) - 1;",
			"    for (; i >= 0; --i) {",
			"        if (val[i] != 0) {",
			"            isPositive = val[i--] > 0;",
			"            break;",
			"        }",
			"    }",
			"    if (isPositive) {",
			"        for (; i >= 0; --i) {",
			"            if (val[i] < 0) {",
			"                int k = 0, index = i + 1;",
			"                for (; (size_t) (index) < val.size() && val[index] == 0; ++k, ++index)",
			"                    ;",
			"                {",
			"                    val[index] -= 1;",
			"                    val[i] += BASE;",
			"                    for (; k > 0; --k) {",
			"                        val[i + k] = UPPER_BOUND;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    } else {",
			"        for (; i >= 0; --i) {",
			"            if (val[i] > 0) {",
			"                int k = 0, index = i + 1;",
			"                for (; (size_t) (index) < val.size() && val[index] == 0; ++k, ++index)",
			"                    ;",
			"                {",
			"                    val[index] += 1;",
			"                    val[i] -= BASE;",
			"                    for (; k > 0; --k) {",
			"                        val[i + k] = -UPPER_BOUND;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return isPositive;",
			"}",
			"",
			"inline void big_int::remove_leading_zeros() {",
			"    for (int i = (int) (val.size()) - 1; i > 0; --i) {",
			"        if (val[i] != 0) {",
			"            return;",
			"        } else {",
			"            val.erase(val.begin() + i);",
			"        }",
			"    }",
			"}",
			"",
			"inline void big_int::correct(bool check_leading_zeros, bool has_valid_sign) {",
			"    if (!check_leading_zeros) {",
			"        truncate_to_base();",
			"        if (equalize_signs()) {",
			"            pos = ((val.size() == 1 && val[0] == 0) || !has_valid_sign) ? true : pos;",
			"        } else {",
			"            pos = has_valid_sign ? !pos : false;",
			"            for (int& i : val) {",
			"                i = abs(i);",
			"            }",
			"        }",
			"    }",
			"    remove_leading_zeros();",
			"}",
			"",
			"inline void big_int::from_string(const std::string& s) {",
			"    pos = true;",
			"    val.clear();",
			"    val.reserve(s.size() / DIGIT_COUNT + 1);",
			"    int i = (int) s.size() - DIGIT_COUNT;",
			"    for (; i >= 0; i -= DIGIT_COUNT) {",
			"        val.push_back(atoi(s.substr(i, DIGIT_COUNT).c_str()));",
			"    }",
			"    if (i > -DIGIT_COUNT) {",
			"        std::string ss = s.substr(0, i + DIGIT_COUNT);",
			"        if (ss.size() == 1 && ss[0] == '-') {",
			"            pos = false;",
			"        } else {",
			"            val.push_back(atoi(ss.c_str()));",
			"        }",
			"    }",
			"    if (val.back() < 0) {",
			"        val.back() = -val.back();",
			"        pos = false;",
			"    }",
			"    correct(true);",
			"}",
			"",
			"inline int big_int::d_i_n_r(const big_int& R, const big_int& D) {",
			"    int min = 0, max = UPPER_BOUND;",
			"    while (max > min) {",
			"        int avg = max + min;",
			"        div_t dt = my_div(avg, 2);",
			"        avg = dt.rem ? (dt.quot + 1) : dt.quot;",
			"        big_int prod = D * avg;",
			"        if (R == prod) {",
			"            return avg;",
			"        } else if (R > prod) {",
			"            min = avg;",
			"        } else {",
			"            max = avg - 1;",
			"        }",
			"    }",
			"    return min;",
			"}",
			"",
			"inline void big_int::multiply_by_digit(int factor, std::vector<int>& val) {",
			"    int carry = 0;",
			"    for (int& i : val) {",
			"        int64_t pval = i * (int64_t) factor + carry;",
			"        if (pval >= BASE || pval <= -BASE) {",
			"            lldiv_t dt = my_lldiv(pval, BASE);",
			"            carry = (int) dt.quot;",
			"            pval = dt.rem;",
			"        } else {",
			"            carry = 0;",
			"        }",
			"        i = (int) pval;",
			"    }",
			"    if (carry > 0) {",
			"        val.push_back(carry);",
			"    }",
			"}",
			"",
			"inline std::istream& operator>>(std::istream& s, big_int& n) {",
			"    std::string str;",
			"    s >> str;",
			"    n.from_string(str);",
			"    return s;",
			"}",
			"inline std::ostream& operator<<(std::ostream& s, const big_int& n) {",
			"    if (!n.pos) s << '-';",
			"    bool first = true;",
			"    for (int i = int(n.val.size()) - 1; i >= 0; --i) {",
			"        if (first) {",
			"            s << n.val[i];",
			"            first = false;",
			"        } else {",
			"            s << std::setfill('0') << std::setw(DIGIT_COUNT) << n.val[i];",
			"        }",
			"    }",
			"    return s;",
			"}",
		],
		"description": ""
	},
	"binarysearch": {
		"prefix": "Binary Search Template",
		"body": [
			"int l = ${1:0}, r = ${2:n - 1}, ans = -1;",
			"while (l <= r) {",
			"    int mid = l + (r - l) / 2;",
			"    if (${3:condition}) {",
			"        ans = mid;",
			"        l = mid + 1;",
			"    } else {",
			"        r = mid - 1;",
			"    }",
			"}",
		],
		"description": ""
	},
}